{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pydantic SchemaForms","text":"<p>Support Python Versions</p> <p> </p> <p>CI/CD Pipeline: </p> <p>SonarCloud:</p> <p> </p> <p>Note: This project should be considered in beta as it is actively under development and may have breaking changes.</p>"},{"location":"#overview","title":"Overview","text":"<p>pydantic-schemaforms is a modern Python library that generates dynamic HTML forms from Pydantic 2.x+ models.</p> <p>It is designed for server-rendered apps: you define a model (and optional UI hints) and get back ready-to-embed HTML with validation and framework styling.</p> <p>Key Features: - \ud83d\ude80 Zero-Configuration Forms: Generate complete HTML forms directly from Pydantic models - \ud83c\udfa8 Multi-Framework Support: Bootstrap, Material Design, Tailwind CSS, and custom frameworks - \u2705 Built-in Validation: Client-side HTML5 + server-side Pydantic validation - \ud83d\udd27 React JSON Schema Forms Compatible: Uses familiar <code>ui_element</code>, <code>ui_autofocus</code>, <code>ui_options</code> syntax - \ud83d\udcf1 Responsive &amp; Accessible: Mobile-first design with full ARIA support - \ud83c\udf10 Framework Ready: First-class Flask and FastAPI helpers, plus plain HTML for other stacks</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Docs site: https://devsetgo.github.io/pydantic-schemaforms/</li> <li>Source: https://github.com/devsetgo/pydantic-schemaforms</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.14+</li> <li>Pydantic 2.7+</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#install","title":"Install","text":"<pre><code>pip install pydantic-schemaforms\n</code></pre>"},{"location":"#fastapi-async-asgi","title":"FastAPI (async / ASGI)","text":"<p>This is the recommended pattern for FastAPI: build a form once per request and use <code>handle_form_async()</code>.</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom pydantic import BaseModel, EmailStr\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form_async\n\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n\n\napp = FastAPI()\n\n\n@app.api_route(\"/user\", methods=[\"GET\", \"POST\"], response_class=HTMLResponse)\nasync def user_form(request: Request):\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        form = await request.form()\n        result = await handle_form_async(builder, submitted_data=dict(form))\n        if result.get(\"success\"):\n            return f\"Saved: {result['data']}\"\n        return result[\"form_html\"]\n\n    result = await handle_form_async(builder)\n    return result[\"form_html\"]\n</code></pre> <p>Run it:</p> <pre><code>pip install \"pydantic-schemaforms[fastapi]\" uvicorn\nuvicorn main:app --reload\n</code></pre>"},{"location":"#flask-sync-wsgi","title":"Flask (sync / WSGI)","text":"<p>In synchronous apps (Flask), use <code>handle_form()</code>.</p> <pre><code>from flask import Flask, request\nfrom pydantic import BaseModel, EmailStr\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form\n\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n\n\napp = Flask(__name__)\n\n\n@app.route(\"/user\", methods=[\"GET\", \"POST\"])\ndef user_form():\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        result = handle_form(builder, submitted_data=request.form.to_dict())\n        if result.get(\"success\"):\n            return f\"Saved: {result['data']}\"\n        return result[\"form_html\"]\n\n    return handle_form(builder)[\"form_html\"]\n</code></pre>"},{"location":"#react-json-schema-forms-compatibility","title":"React JSON Schema Forms Compatibility","text":"<p>The library supports a React JSON Schema Forms-style vocabulary (UI hints like input types and options), but you can also stay \u201cpure Pydantic\u201d and let the defaults drive everything.</p> <p>See the docs site for the current, supported UI hint patterns.</p>"},{"location":"#framework-support","title":"Framework Support","text":""},{"location":"#bootstrap-5-recommended","title":"Bootstrap 5 (Recommended)","text":"<p><pre><code>UserForm.render_form(framework=\"bootstrap\", submit_url=\"/submit\")\n</code></pre> - Complete Bootstrap integration - Form validation states and styling - Responsive grid system - Custom form controls</p>"},{"location":"#material-design","title":"Material Design","text":"<p><pre><code>UserForm.render_form(framework=\"material\", submit_url=\"/submit\")\n</code></pre> - Materialize CSS framework - Floating labels and animations - Material icons integration</p>"},{"location":"#plain-html","title":"Plain HTML","text":"<p><pre><code>UserForm.render_form(framework=\"none\", submit_url=\"/submit\")\n</code></pre> - Clean HTML5 forms - No framework dependencies - Easy to style with custom CSS</p>"},{"location":"#renderer-architecture","title":"Renderer Architecture","text":"<ul> <li>EnhancedFormRenderer is the canonical renderer. It walks the Pydantic <code>FormModel</code>, feeds the shared <code>LayoutEngine</code>, and delegates chrome/assets to a <code>RendererTheme</code>.</li> <li>ModernFormRenderer now piggybacks on Enhanced by generating a throwaway <code>FormModel</code> from legacy <code>FormDefinition</code>/<code>FormField</code> helpers. It exists so existing builder/integration code keeps working while still benefiting from the shared pipeline. (The old <code>Py314Renderer</code> alias has been removed; import <code>ModernFormRenderer</code> directly when you need the builder DSL.)</li> </ul> <p>Because everything flows through Enhanced, fixes to layout, validation, or framework themes immediately apply to every renderer (Bootstrap, Material, embedded/self-contained, etc.). Choose the renderer based on the API surface you prefer (Pydantic models for <code>FormModel</code> or the builder DSL for <code>ModernFormRenderer</code>); the generated HTML is orchestrated by the same core engine either way.</p>"},{"location":"#advanced-examples","title":"Advanced Examples","text":""},{"location":"#file-upload-form","title":"File Upload Form","text":"<pre><code>class FileUploadForm(FormModel):\n    title: str = Field(..., description=\"Upload title\")\n    files: str = Field(\n        ...,\n        description=\"Select files\",\n        ui_element=\"file\",\n        ui_options={\"accept\": \".pdf,.docx\", \"multiple\": True}\n    )\n    description: str = Field(\n        ...,\n        description=\"File description\",\n        ui_element=\"textarea\",\n        ui_options={\"rows\": 3}\n    )\n</code></pre>"},{"location":"#event-creation-form","title":"Event Creation Form","text":"<pre><code>class EventForm(FormModel):\n    event_name: str = Field(..., description=\"Event name\", ui_autofocus=True)\n    event_datetime: str = Field(\n        ...,\n        description=\"Event date and time\",\n        ui_element=\"datetime-local\"\n    )\n    max_attendees: int = Field(\n        ...,\n        ge=1,\n        le=1000,\n        description=\"Maximum attendees\",\n        ui_element=\"number\"\n    )\n    is_public: bool = Field(\n        True,\n        description=\"Make event public\",\n        ui_element=\"checkbox\"\n    )\n    theme_color: str = Field(\n        \"#3498db\",\n        description=\"Event color\",\n        ui_element=\"color\"\n    )\n</code></pre>"},{"location":"#form-validation","title":"Form Validation","text":"<pre><code>from pydantic import ValidationError\n\n@app.route(\"/submit\", methods=[\"POST\"])\ndef handle_submit():\n    try:\n        # Validate form data using your Pydantic model\n        user_data = UserForm(**request.form)\n\n        # Process valid data\n        return f\"Welcome {user_data.username}!\"\n\n    except ValidationError as e:\n        # Handle validation errors\n        errors = e.errors()\n        return f\"Validation failed: {errors}\", 400\n</code></pre>"},{"location":"#flask-integration","title":"Flask Integration","text":"<p>Complete Flask application example:</p> <pre><code>from flask import Flask, request, render_template_string\nfrom pydantic import ValidationError\nfrom pydantic_schemaforms.schema_form import FormModel, Field\n\napp = Flask(__name__)\n\nclass UserRegistrationForm(FormModel):\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=20,\n        description=\"Choose a unique username\",\n        ui_autofocus=True\n    )\n    email: str = Field(\n        ...,\n        description=\"Your email address\",\n        ui_element=\"email\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        description=\"Choose a secure password\",\n        ui_element=\"password\"\n    )\n    age: int = Field(\n        ...,\n        ge=13,\n        le=120,\n        description=\"Your age\",\n        ui_element=\"number\"\n    )\n    newsletter: bool = Field(\n        False,\n        description=\"Subscribe to our newsletter\",\n        ui_element=\"checkbox\"\n    )\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef registration():\n    if request.method == \"POST\":\n        try:\n            # Validate form data\n            user = UserRegistrationForm(**request.form)\n            return f\"Registration successful for {user.username}!\"\n        except ValidationError as e:\n            errors = e.errors()\n            # Re-render form with errors\n            form_html = UserRegistrationForm.render_form(\n                framework=\"bootstrap\",\n                submit_url=\"/\",\n                errors=errors\n            )\n            return render_template_string(BASE_TEMPLATE, form_html=form_html)\n\n    # Render empty form\n    form_html = UserRegistrationForm.render_form(framework=\"bootstrap\", submit_url=\"/\")\n    return render_template_string(BASE_TEMPLATE, form_html=form_html)\n\nBASE_TEMPLATE = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;User Registration&lt;/title&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container my-5\"&gt;\n        &lt;h1&gt;User Registration&lt;/h1&gt;\n        {{ form_html | safe }}\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"#examples-in-this-repository","title":"Examples in This Repository","text":"<p>The repository includes several complete examples:</p> <ol> <li><code>example_usage.py</code> - React JSON Schema Forms compatible examples</li> <li><code>pydantic_example.py</code> - Flask integration with multiple form types</li> <li><code>simple_example.py</code> - Basic usage without frameworks</li> <li><code>example.py</code> - Low-level UI components demonstration</li> </ol> <p>Run any example: <pre><code>python example_usage.py     # http://localhost:5000\npython pydantic_example.py  # http://localhost:5001\npython example.py           # http://localhost:5002\n</code></pre></p>"},{"location":"#supported-input-types","title":"Supported Input Types","text":"<p>Text Inputs: - <code>text</code> (default), <code>email</code>, <code>password</code>, <code>search</code> - <code>tel</code>, <code>url</code> - <code>textarea</code></p> <p>Numeric Inputs: - <code>number</code>, <code>range</code></p> <p>Date/Time Inputs: - <code>date</code>, <code>time</code>, <code>datetime-local</code> - <code>week</code>, <code>month</code></p> <p>Selection Inputs: - <code>checkbox</code>, <code>radio</code>, <code>select</code></p> <p>Specialized Inputs: - <code>file</code>, <code>color</code>, <code>hidden</code></p> <p>Input Options: All HTML5 input attributes are supported through <code>ui_options</code> or Field parameters.</p>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#formmodel","title":"FormModel","text":"<p>Extend your Pydantic models with <code>FormModel</code> to add form rendering capabilities:</p> <pre><code>from pydantic_schemaforms.schema_form import FormModel, Field\n\nclass MyForm(FormModel):\n    field_name: str = Field(..., ui_element=\"email\")\n\n    @classmethod\n    def render_form(cls, framework=\"bootstrap\", submit_url=\"/submit\", **kwargs):\n        \"\"\"Render complete HTML form\"\"\"\n</code></pre>"},{"location":"#field-function","title":"Field Function","text":"<p>Enhanced Field function with UI element support:</p> <pre><code>Field(\n    default=...,           # Pydantic default value\n    description=\"Label\",   # Field label\n    ui_element=\"email\",    # Input type\n    ui_autofocus=True,     # Auto-focus field\n    ui_options={...},      # Additional options\n    # All standard Pydantic Field options...\n)\n</code></pre>"},{"location":"#framework-options","title":"Framework Options","text":"<ul> <li><code>\"bootstrap\"</code> - Bootstrap 5 styling (recommended)</li> <li><code>\"material\"</code> - Material Design (Materialize CSS)</li> <li><code>\"none\"</code> - Plain HTML5 forms</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please check out the Contributing Guide for details.</p> <p>Development Setup: <pre><code>git clone https://github.com/devsetgo/pydantic-schemaforms.git\ncd pydantic-schemaforms\npip install -e .\n</code></pre></p> <p>Run Tests: <pre><code>python -m pytest tests/\n</code></pre></p>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: pydantic-schemaforms Docs</li> <li>Repository: GitHub</li> <li>PyPI: pydantic-schemaforms</li> <li>Issues: Bug Reports &amp; Feature Requests</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details: https://github.com/devsetgo/pydantic-schemaforms/blob/main/LICENSE</p>"},{"location":"about/","title":"About","text":"<p><code>pydantic-schemaforms</code> is a Python library for generating server-rendered HTML forms from Pydantic models.</p> <p>It focuses on:</p> <ul> <li>A simple model \u2192 schema \u2192 HTML pipeline</li> <li>First-class sync (WSGI) and async (ASGI) integration helpers</li> <li>Offline-by-default asset delivery (vendored/inlined assets), with explicit opt-in for CDNs</li> </ul> <p>Project links:</p> <ul> <li>Docs: https://devsetgo.github.io/pydantic-schemaforms/</li> <li>GitHub: https://github.com/devsetgo/pydantic-schemaforms</li> <li>PyPI: https://pypi.org/project/pydantic-schemaforms/</li> </ul>"},{"location":"about/#about-me","title":"About Me","text":"<p>I am a software engineering manager with an eclectic background in various industries (finance, manufacturing, and metrology). I am passionate about software development and love to learn new things.</p> <ul> <li>DevSetGo.com</li> <li>Github</li> <li>X.com</li> </ul>"},{"location":"assets/","title":"Assets &amp; <code>asset_mode</code>","text":"<p><code>pydantic-schemaforms</code> is offline-by-default: by default, rendered HTML ships all required JS/CSS from this library (vendored assets are embedded/packaged).</p> <p>This page documents the standard knobs used across entry points to control asset injection.</p>"},{"location":"assets/#terminology","title":"Terminology","text":"<ul> <li>Vendored assets: Third-party JS/CSS copied into this repo under <code>pydantic_schemaforms/assets/vendor/**</code>.</li> <li>Pinned: Versions are recorded in <code>pydantic_schemaforms/assets/vendor/vendor_manifest.json</code> along with <code>sha256</code> checksums and source URLs.</li> <li><code>asset_mode</code>: How a renderer should include assets.</li> </ul>"},{"location":"assets/#asset_mode-values","title":"<code>asset_mode</code> values","text":"<p>Most APIs accept <code>asset_mode</code> with these values:</p> <ul> <li><code>\"vendored\"</code> (default)</li> <li>No external network required.</li> <li> <p>Assets are inlined (e.g., <code>&lt;script&gt;\u2026&lt;/script&gt;</code> / <code>&lt;style&gt;\u2026&lt;/style&gt;</code>) from the packaged vendor files.</p> </li> <li> <p><code>\"cdn\"</code> (explicit opt-in)</p> </li> <li>Emits <code>&lt;script src=\"\u2026\"&gt;</code> / <code>&lt;link href=\"\u2026\"&gt;</code> tags pointing at a CDN.</li> <li> <p>URLs are pinned to the versions in the vendored manifest.</p> </li> <li> <p><code>\"none\"</code></p> </li> <li>Emits no assets.</li> <li>Useful when your host app provides its own asset pipeline.</li> </ul>"},{"location":"assets/#entry-points","title":"Entry points","text":""},{"location":"assets/#legacy-wrapper-render_form_html","title":"Legacy wrapper: <code>render_form_html()</code>","text":"<p>File: <code>pydantic_schemaforms/render_form.py</code></p> <ul> <li><code>asset_mode=\"vendored\" | \"cdn\" | \"none\"</code></li> <li>HTMX is included by default (vendored inline) because this wrapper historically assumed HTMX.</li> <li>IMask is available but not injected unless requested.</li> </ul> <p>Example:</p> <pre><code>from pydantic_schemaforms.render_form import render_form_html\n\nhtml = render_form_html(\n    MyForm,\n    framework=\"bootstrap\",\n    asset_mode=\"vendored\",\n    include_imask=True,  # enable when you use masked inputs\n)\n</code></pre>"},{"location":"assets/#enhanced-renderer-enhancedformrenderer","title":"Enhanced renderer: <code>EnhancedFormRenderer</code>","text":"<p>File: <code>pydantic_schemaforms/enhanced_renderer.py</code></p> <ul> <li><code>include_framework_assets</code>: whether the renderer should include framework CSS/JS.</li> <li><code>asset_mode</code>: controls whether those assets are vendored inline or pinned CDN URLs.</li> </ul> <p>Example:</p> <pre><code>from pydantic_schemaforms.enhanced_renderer import EnhancedFormRenderer\n\nrenderer = EnhancedFormRenderer(\n    framework=\"bootstrap\",\n    include_framework_assets=True,\n    asset_mode=\"vendored\",\n)\nhtml = renderer.render_form_from_model(MyForm)\n</code></pre>"},{"location":"assets/#modernbuilder-path-formbuilder-render_form_page","title":"Modern/builder path: <code>FormBuilder</code> + <code>render_form_page()</code>","text":"<p>File: <code>pydantic_schemaforms/integration/builder.py</code></p> <ul> <li><code>FormBuilder(..., include_framework_assets=..., asset_mode=...)</code> controls how the builder\u2019s form HTML is rendered.</li> <li><code>render_form_page(..., include_framework_assets=..., asset_mode=...)</code> controls the full-page wrapper\u2019s CSS/JS emission.</li> </ul> <p>Example:</p> <pre><code>from pydantic_schemaforms.integration.builder import FormBuilder, render_form_page\n\nbuilder = FormBuilder(\n    framework=\"bootstrap\",\n    include_framework_assets=True,\n    asset_mode=\"vendored\",\n).text_input(\"ssn\", \"SSN\")\n\npage = render_form_page(\n    builder,\n    title=\"Signup\",\n    include_framework_assets=True,\n    asset_mode=\"vendored\",\n)\n</code></pre>"},{"location":"assets/#whats-currently-vendored","title":"What\u2019s currently vendored","text":"<ul> <li>HTMX</li> <li>IMask</li> <li>Bootstrap (CSS + bundle JS)</li> <li>Materialize (CSS + JS)</li> </ul> <p>See <code>pydantic_schemaforms/assets/vendor/vendor_manifest.json</code> for exact versions and file paths.</p>"},{"location":"assets/#updating-vendored-assets","title":"Updating vendored assets","text":"<p>Vendored updates are scripted and checksum-verified.</p> <ul> <li>Verify vendored checksums:</li> <li> <p><code>make vendor-verify</code></p> </li> <li> <p>Update assets:</p> </li> <li><code>make vendor-update-htmx HTMX_VERSION=\u2026</code></li> <li><code>make vendor-update-imask IMASK_VERSION=\u2026</code> (or omit to use npm latest)</li> <li><code>make vendor-update-bootstrap BOOTSTRAP_VERSION=\u2026</code></li> <li><code>make vendor-update-materialize MATERIALIZE_VERSION=\u2026</code></li> </ul> <p>After updating, run <code>make vendor-verify</code> and the test suite.</p>"},{"location":"assets/#security-note","title":"Security note","text":"<p><code>asset_mode=\"cdn\"</code> is intentionally available, but it re-introduces an external dependency at runtime. For production systems with strict supply-chain or offline requirements, prefer <code>asset_mode=\"vendored\"</code>.</p>"},{"location":"contribute/","title":"Contributing","text":"<p>Please feel free to contribute to this project. Adding common functions is the intent and if you have one to add or improve an existing it is greatly appreciated.</p>"},{"location":"contribute/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Add or improve a function</li> <li>Add or improve documentation</li> <li>Add or improve tests</li> <li>Report or fix a bug</li> </ul>"},{"location":"plugin_hooks/","title":"Plugin Hooks for Inputs and Layouts","text":"<p>This project now exposes lightweight extension points so third-party packages (or your own app code) can add new inputs or layout renderers without patching core modules.</p>"},{"location":"plugin_hooks/#registering-custom-inputs","title":"Registering Custom Inputs","text":"<p>Use <code>pydantic_schemaforms.inputs.registry.register_input_class</code> to bind a <code>BaseInput</code> subclass to one or more <code>ui_element</code> aliases. The registry augments the built-in discovery of subclasses so you can register at import time or inside your framework startup.</p> <pre><code>from pydantic_schemaforms.inputs.base import BaseInput\nfrom pydantic_schemaforms.inputs.registry import register_input_class\n\nclass ColorSwatchInput(BaseInput):\n    ui_element = \"color_swatch\"\n\n    # implement render_input / render_label, etc.\n\nregister_input_class(ColorSwatchInput)\n</code></pre> <ul> <li>Aliases: pass <code>aliases=(\"color\", \"swatch\")</code> if you want multiple trigger names.</li> <li>Bulk registration: use <code>register_inputs([Cls1, Cls2, ...])</code>.</li> <li>Reset (tests/hot reload): <code>reset_input_registry()</code> clears custom entries and cache.</li> </ul> <p>Once registered, any field with <code>input_type=\"color_swatch\"</code> (or alias) will resolve to your component.</p>"},{"location":"plugin_hooks/#registering-custom-layout-renderers","title":"Registering Custom Layout Renderers","text":"<p><code>LayoutEngine</code> can now dispatch layout fields to custom renderers before falling back to built-in demos. Provide a callable and reference it from a field via <code>layout_handler</code> (or <code>layout_renderer</code>) in <code>json_schema_extra</code> / <code>FormField</code> kwargs.</p> <pre><code>from pydantic_schemaforms.rendering.layout_engine import LayoutEngine\n\n# signature: (field_name, field_schema, value, ui_info, context, engine) -&gt; str\ndef render_steps(field_name, field_schema, value, ui_info, context, engine):\n    # value may be your own layout descriptor; use engine._renderer if needed\n    steps = value or []\n    items = \"\".join(f\"&lt;li&gt;{step}&lt;/li&gt;\" for step in steps)\n    return f\"&lt;ol class='steps'&gt;{items}&lt;/ol&gt;\"\n\nLayoutEngine.register_layout_renderer(\"steps\", render_steps)\n</code></pre> <p>Attach the handler in your form field:</p> <pre><code>class WizardForm(FormModel):\n    steps: list[str] = FormField(\n        [\"Account\", \"Billing\", \"Review\"],\n        input_type=\"layout\",\n        layout_handler=\"steps\",\n        title=\"Wizard Steps\",\n    )\n</code></pre> <ul> <li>Names are arbitrary strings; collisions overwrite the previous handler.</li> <li>Call <code>LayoutEngine.reset_layout_renderers()</code> in tests to clear state.</li> <li>Handlers receive the active <code>LayoutEngine</code> instance and the original renderer via <code>engine._renderer</code> if you need to reuse field rendering helpers.</li> </ul>"},{"location":"plugin_hooks/#packaging-tips","title":"Packaging Tips","text":"<ul> <li>For libraries: register your inputs/layouts in your package <code>__init__</code> or an explicit <code>setup()</code> function that users call during startup.</li> <li>For app code: register once at process start (e.g., FastAPI lifespan, Django AppConfig.ready). Avoid per-request registration.</li> <li>Keep renderers pure and side-effect free; they should return HTML strings and not mutate shared state.</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This page shows the one recommended way to integrate pydantic-schemaforms into an app:</p> <ul> <li>Build a <code>FormBuilder</code> (often via <code>create_form_from_model()</code>)</li> <li>Use exactly one handler per runtime:</li> <li>Sync: <code>handle_form()</code></li> <li>Async: <code>handle_form_async()</code></li> </ul>"},{"location":"quickstart/#1-build-a-form-from-a-pydantic-model","title":"1) Build a form from a Pydantic model","text":"<pre><code>from pydantic import BaseModel, EmailStr\n\nfrom pydantic_schemaforms import create_form_from_model\n\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n\n\nbuilder = create_form_from_model(User, framework=\"bootstrap\")\n</code></pre>"},{"location":"quickstart/#2-sync-integration-flask-wsgi","title":"2) Sync integration (Flask / WSGI)","text":"<pre><code>from flask import Flask, request\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form\n\napp = Flask(__name__)\n\n\n@app.route(\"/user\", methods=[\"GET\", \"POST\"])\ndef user_form():\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        result = handle_form(builder, submitted_data=request.form.to_dict())\n        if result.get(\"success\"):\n            return f\"Saved: {result['data']}\"\n        return result[\"form_html\"]\n\n    return handle_form(builder)[\"form_html\"]\n</code></pre>"},{"location":"quickstart/#3-async-integration-fastapi-asgi","title":"3) Async integration (FastAPI / ASGI)","text":"<pre><code>from fastapi import FastAPI, Request\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form_async\n\napp = FastAPI()\n\n\n@app.api_route(\"/user\", methods=[\"GET\", \"POST\"])\nasync def user_form(request: Request):\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        form = await request.form()\n        result = await handle_form_async(builder, submitted_data=dict(form))\n        if result.get(\"success\"):\n            return {\"ok\": True, \"data\": result[\"data\"]}\n        return result[\"form_html\"]\n\n    result = await handle_form_async(builder)\n    return result[\"form_html\"]\n</code></pre>"},{"location":"quickstart/#notes","title":"Notes","text":"<ul> <li><code>handle_form*()</code> returns either <code>{form_html}</code> (initial render) or <code>{success: bool, ...}</code> (submission).</li> <li>Asset delivery (<code>asset_mode</code>) and full-page wrappers are documented in <code>docs/assets.md</code>.</li> </ul>"},{"location":"release-notes/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p>"},{"location":"release-notes/#latest-changes","title":"Latest Changes","text":""},{"location":"release-notes/#initial-beta-release-2611beta","title":"Initial Beta Release (26.1.1.beta)","text":""},{"location":"release-notes/#changes","title":"Changes","text":"<ul> <li>GitHub Actions Improvements (#10) (@devsetgo)</li> <li>first release (#9) (@devsetgo)</li> <li>working on documentation (#5) (@devsetgo)</li> <li>working on coverage (#4) (@devsetgo)</li> </ul>"},{"location":"release-notes/#features","title":"Features","text":"<ul> <li>Improving Workflow (#1) (@devsetgo)</li> </ul>"},{"location":"release-notes/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>working on coverage issue (#3) (@devsetgo)</li> <li>working on publishing issue (#2) (@devsetgo)</li> </ul>"},{"location":"release-notes/#maintenance","title":"Maintenance","text":"<ul> <li>updating release drafter (#11) (@devsetgo)</li> <li>Pre-Release Checks (#6) (@devsetgo)</li> </ul>"},{"location":"release-notes/#contributors","title":"Contributors","text":"<p>@devsetgo</p> <p>Published Date: 2026 January 02, 19:13</p>"},{"location":"review/","title":"Codebase Review \u2013 pydantic-schemaforms","text":"<p>Date: 2025-12-21 (Updated)</p>"},{"location":"review/#executive-summary","title":"Executive Summary","text":"<p><code>pydantic-schemaforms</code> is in a solid place architecturally: there is now a single schema\u2192field\u2192layout rendering pipeline, theme/style are first-class and overrideable, and the test suite exercises both sync and async rendering across layout primitives. The remaining work is less about \u201cmore features\u201d and more about locking the product to its original promise:</p> <ul> <li> <p>Python 3.14+ only: this library targets Python 3.14 and higher, and does not support earlier Python versions.</p> </li> <li> <p>ship all required HTML/CSS/JS from the library (no external CDNs by default)</p> </li> <li>keep UI + validation configuration expressed via Pydantic (schema is the source of truth)</li> <li>make sync + async usage boringly simple (one obvious way)</li> <li>add an optional debug rendering mode that helps adoption without changing normal UX</li> </ul> <p>The renderer refactor eliminated shared mutable state and restored the enhanced/material renderers to a working baseline. Schema metadata is cached, field rendering is centralized, and model-list nesting now feeds explicit <code>RenderContext</code> objects. Django integration has been removed (Flask/FastAPI remain), and the JSON/OpenAPI generators now source constraints directly from Pydantic field metadata, unblocking the integration tests. Renderer themes now include a formal <code>FrameworkTheme</code> registry (Bootstrap/Material/plain) plus <code>MaterialEmbeddedTheme</code>, and both <code>EnhancedFormRenderer</code> and <code>FieldRenderer</code> source their form/input/button classes from the active theme before falling back to legacy framework config.</p> <p>Latest (Dec 7, 2025): Theme-driven form chrome extraction is complete. The new <code>FormStyle</code> contract centralizes all framework-specific markup (model lists, tabs, accordions, submit buttons, layout sections, and field-level help/error blocks) in a registry-based system. <code>FormStyleTemplates</code> dataclass now holds 15 template slots (expanded from 13: added <code>field_help</code> and <code>field_error</code> for field-level chrome routing), registered per-framework (Bootstrap/Material/Plain/Default) with graceful fallbacks. <code>RendererTheme</code> and <code>LayoutEngine</code> now query <code>FormStyle.templates</code> at render time instead of inlining markup, enabling runtime overrides without renderer edits. Version-aware style descriptors are supported (e.g., <code>get_form_style(\"bootstrap:5\")</code>, <code>get_form_style(\"material:3\")</code>) with fallback to framework defaults. FastAPI example hardened with absolute paths (<code>Path(__file__).resolve().parent</code>) for templates/static, resolving path issues in tests and different working directories. Validation engine consolidated: <code>ValidationResponse</code> and convenience validators now live in <code>validation.py</code>, <code>live_validation.py</code> consumes/re-exports without duplication, and 10 new consolidation tests were added. Tabs regression fixed: Bootstrap panels now render initial content (<code>show active</code>), Material tabs use shared tab CSS/JS classes so tabs switch correctly, and a layout-demo smoke test asserts initial tab content renders for both frameworks. Pydantic v2 deprecations eliminated: All Pydantic <code>Field()</code> kwargs now properly use <code>json_schema_extra</code> instead of extra kwargs; <code>min_items</code>/<code>max_items</code> replaced with <code>min_length</code>/<code>max_length</code> in FormField calls; Starlette <code>TemplateResponse</code> signature updated to new parameter order (request first). Deprecation warnings suppressed: pytest <code>filterwarnings</code> config reduces test output from 19 warnings to 1 without losing developer guidance (form_layouts deprecation and JSON schema hints remain available with <code>-W default</code>). Validation documentation added: New comprehensive <code>docs/validation_guide.md</code> (787 lines) documents the unified validation engine with ValidationResponse/FieldValidator/FormValidator APIs, server-side and HTMX validation flows, cross-field validation patterns, and end-to-end FastAPI examples.</p> <p>Latest (Dec 21, 2025): The core architecture is now strong enough to support the original product constraints (library supplies HTML/CSS/JS, configuration is expressed via Pydantic, sync+async are easy). The most important product-alignment work is now complete for assets and consistently enforced:</p> <ul> <li>Self-contained assets: Default rendering no longer emits external CDN URLs.</li> <li>HTMX is now vendored and inlined by default (offline-by-default).</li> <li>A CDN mode exists but is explicitly opt-in and pinned to the vendored manifest version.</li> <li>IMask is vendored and available when explicitly requested (e.g., SSN masking).</li> <li>Framework CSS/JS (Bootstrap + Materialize) are vendored and can be emitted inline in <code>asset_mode=\"vendored\"</code>.</li> <li>Consistent asset selection: A consistent <code>asset_mode</code> pattern is now threaded through the main entry points (enhanced renderer, modern renderer/builder, legacy wrappers) so \u201ccdn vs vendored\u201d behavior is deterministic.</li> <li>Operational stability: <code>vendor_manifest.json</code> checksum verification is enforced by tests, and pre-commit is configured to avoid mutating vendored assets and generated test artifacts.</li> <li>Debug rendering mode (COMPLETED): First-class debug panel now available via <code>debug=True</code> flag. The panel exposes (1) rendered HTML/assets, (2) the Python form/model source, (3) validation rules/schema, and (4) live payload with real-time form data capture. Implementation uses JavaScript event listeners to update the live tab as users interact with the form, handles nested model-list fields correctly, and is fully self-contained (inline CSS/JS). FastAPI example updated with <code>?debug=1</code> support on all routes, and tests verify correct behavior.</li> </ul>"},{"location":"review/#design-rules-nonnegotiables","title":"Design Rules (Non\u2011Negotiables)","text":"<p>These rules are intended to prevent \u201chelpful\u201d drift away from the original concept.</p> <ol> <li>Python version policy</li> <li>The library supports Python 3.14 and higher only.</li> <li> <p>Avoid guidance that suggests compatibility with older Python versions.</p> </li> <li> <p>Library ships the experience</p> <ul> <li>Default output must be fully functional offline: no third-party CDN assets (JS/CSS/fonts) unless explicitly opted in.</li> <li>Framework integrations may serve assets, but the assets must come from this package.</li> </ul> </li> <li> <p>Pydantic is the single source of truth</p> <ul> <li>Validation constraints, required/optional, and shape come from Pydantic schema/Field metadata.</li> <li>UI configuration is expressed via Pydantic-friendly metadata (<code>json_schema_extra</code> / form field helpers) rather than ad-hoc runtime flags.</li> <li>Avoid storing non-JSON-serializable objects in schema extras unless they are sanitized for schema generation.</li> </ul> </li> <li> <p>One obvious way (sync + async)</p> <ul> <li>There should be exactly one recommended sync entry point and one async entry point.</li> <li>All other helpers should be thin compatibility wrappers and should not diverge in behavior.</li> </ul> </li> <li> <p>Renderer outputs deterministic, self-contained HTML</p> <ul> <li>Rendering should not depend on global mutable state or ambient process configuration.</li> <li>Rendering should be deterministic for the same model + config.</li> </ul> </li> <li> <p>Debug mode is optional and non-invasive</p> <ul> <li>Debug UI must be off by default.</li> <li>When enabled, it should wrap the existing form (collapsed panel) and never change validation/rendering semantics.</li> <li>Debug surfaces should be \u201cread-only views\u201d of: rendered HTML/assets, model source (best effort), schema/validation rules, and live validation payloads.</li> </ul> </li> <li> <p>Extensibility stays declarative</p> <ul> <li>Plugins register inputs/layout renderers via the official registries; no monkeypatching required.</li> <li>Extension points should compose with themes/styles, not bypass them.</li> </ul> </li> </ol>"},{"location":"review/#critical-high-priority-findings","title":"Critical / High Priority Findings","text":"<ul> <li> <p>External CDN assets violate the self-contained requirement (Addressed)   Default output is now offline-by-default across the main entry points.</p> </li> <li> <p>HTMX is vendored and inlined by default.</p> </li> <li>An explicit <code>asset_mode=\"cdn\"</code> exists for users who want CDN delivery, but it is pinned to the vendored manifest version.</li> <li>IMask is vendored and available for secure inputs (e.g., SSN masking). It is not injected unless explicitly requested.</li> <li>Framework CSS/JS (Bootstrap + Materialize) are vendored and can be emitted in <code>asset_mode=\"vendored\"</code> (inline) to keep \u201cframework look\u201d self-contained.</li> <li>External CDN URLs still exist as an explicit opt-in (<code>asset_mode=\"cdn\"</code>) and are pinned to the vendored manifest versions.</li> </ul> <p>Files:   - <code>pydantic_schemaforms/render_form.py</code> (legacy wrapper)   - <code>pydantic_schemaforms/assets/runtime.py</code> (vendored HTMX + pinned CDN mode)   - <code>pydantic_schemaforms/rendering/themes.py</code> / <code>pydantic_schemaforms/enhanced_renderer.py</code> (asset-mode gating)   - <code>pydantic_schemaforms/modern_renderer.py</code>, <code>pydantic_schemaforms/integration/builder.py</code> (builder/modern entry points)   - <code>pydantic_schemaforms/form_layouts.py</code> (deprecated legacy layouts; now gated)</p> <p>Vendored dependency policy (implemented for HTMX; extendable for others)   - Default is offline: the default renderer output must not reference external CDNs.   - Pinned + auditable: every vendored asset must be pinned to an explicit version and recorded with <code>source_url</code> + <code>sha256</code> in a manifest.   - Licenses included: upstream license text (and any required notices) must be included in the repo alongside the vendored asset (or clearly referenced if inclusion is not permitted).   - Single update path: updates must happen via an explicit script + make target (no manual copy/paste), so diffs are reproducible.   - Opt-in CDN mode only: if a CDN mode exists, it must be explicitly selected (never default) and clearly documented as not-offline.</p> <p>What \u201ceasy to update\u201d means (definition)   - One command updates the pinned version, downloads the asset(s), writes/updates the manifest checksums, and runs a verification check.   - A CI/test check fails if any default render output contains external asset URLs.   - The update process is deterministic and reviewable (diff shows only asset bytes + manifest/version bump).   - Formatting/lint tooling must not modify vendored bytes (otherwise checksum verification breaks). Pre-commit should exclude <code>pydantic_schemaforms/assets/vendor/</code> from whitespace/EOF normalization hooks.</p> <ul> <li> <p>Multiple layout stacks compete for ownership (Resolved)   Layout definitions now live exclusively in <code>layout_base.BaseLayout</code> + <code>rendering/layout_engine</code>. The new <code>LayoutComposer</code> API exposes the canonical Horizontal/Vertical/Tabbed primitives, while <code>pydantic_schemaforms.layouts</code>/<code>pydantic_schemaforms.form_layouts</code> only re-export the engine with <code>DeprecationWarning</code>s. Enhanced and Material renderers both call into <code>LayoutEngine</code>, so markup is consistent across frameworks, and the tutorial documents LayoutComposer as the single supported API.   Files: <code>pydantic_schemaforms/rendering/layout_engine.py</code>, <code>pydantic_schemaforms/layouts.py</code>, <code>pydantic_schemaforms/form_layouts.py</code>, <code>pydantic_schemaforms/simple_material_renderer.py</code></p> </li> <li> <p>Renderer logic duplicated across frameworks (Resolved)   Enhanced and Simple Material share the same orchestration pipeline via the new <code>RendererTheme</code> abstraction and <code>MaterialEmbeddedTheme</code>, eliminating the duplicated CSS/JS scaffolding that previously lived in <code>simple_material_renderer.py</code>. The Modern renderer now builds a temporary <code>FormModel</code> and hands off to <code>EnhancedFormRenderer</code>, and the redundant <code>Py314Renderer</code> alias has been removed entirely. Framework-specific assets live in <code>RendererTheme</code> strategies, so there is a single schema walk/layout path regardless of entry point.   Files: <code>pydantic_schemaforms/enhanced_renderer.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code>, <code>pydantic_schemaforms/simple_material_renderer.py</code>, <code>pydantic_schemaforms/modern_renderer.py</code></p> </li> <li> <p>Integration helpers mix unrelated responsibilities (Addressed)   The synchronous/async adapters now live in <code>pydantic_schemaforms/integration/frameworks/</code>, leaving the root <code>integration</code> package to expose only builder/schema utilities by default. The module uses lazy exports so simply importing <code>pydantic_schemaforms.integration</code> no longer drags in optional framework glue unless those helpers are actually accessed.   Files: <code>pydantic_schemaforms/integration/__init__.py</code>, <code>pydantic_schemaforms/integration/frameworks/</code>, <code>pydantic_schemaforms/integration/builder.py</code></p> </li> </ul>"},{"location":"review/#medium-priority-refactors-opportunities","title":"Medium Priority Refactors &amp; Opportunities","text":"<ul> <li> <p>Input component metadata duplicated (Resolved)   Input classes now declare their <code>ui_element</code> (plus optional aliases) and a lightweight registry walks the class hierarchy to expose a mapping. <code>rendering/frameworks.py</code> imports that registry instead of maintaining its own list, so adding a new component only requires updating the input module where it already lives.   Files: <code>pydantic_schemaforms/inputs/base.py</code>, <code>pydantic_schemaforms/inputs/*</code>, <code>pydantic_schemaforms/inputs/registry.py</code>, <code>pydantic_schemaforms/rendering/frameworks.py</code></p> </li> <li> <p>Model list renderer mixes logic with theme markup (Resolved) <code>ModelListRenderer</code> now delegates both containers and per-item chrome through <code>RendererTheme</code> hooks: <code>render_model_list_container()</code> and the new <code>render_model_list_item()</code> (with Material/embedded overrides) wrap the renderer-supplied field grid so frameworks own every byte of markup. Bootstrap/Material share the same plumbing, labels/help/errors/add buttons stay in the theme, and tests cover that custom themes can inject their own classes when rendering lists.   Files: <code>pydantic_schemaforms/model_list.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code></p> </li> <li> <p>Template engine under-used (Resolved)   The new <code>FormStyle</code> contract (in <code>rendering/form_style.py</code>) extracts all framework-specific markup into <code>FormStyleTemplates</code> dataclass with 13 template slots: <code>form_wrapper</code>, <code>tab_layout</code>, <code>tab_button</code>, <code>tab_panel</code>, <code>accordion_layout</code>, <code>accordion_section</code>, <code>layout_section</code>, <code>layout_help</code>, <code>model_list_container</code>, <code>model_list_item</code>, <code>model_list_help</code>, <code>model_list_error</code>, and <code>submit_button</code>. Framework-specific bundles (Bootstrap, Material, Plain, Default) are registered in a centralized registry via <code>register_form_style()</code> and queried at render time with <code>get_form_style(framework, variant)</code>. <code>RendererTheme.render_submit_button()</code>, <code>render_model_list_*()</code> methods and <code>LayoutEngine</code> tab/accordion layouts all delegate to <code>FormStyle.templates</code> with graceful fallback to defaults, eliminating inline markup strings and enabling runtime overrides. Tests in <code>test_theme_hooks.py</code> (7 tests) verify custom FormStyle templates drive rendering. FastAPI example paths hardened to use <code>Path(__file__).resolve().parent</code> for templates and static dirs, working correctly from any working directory.   Files: <code>pydantic_schemaforms/rendering/form_style.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code>, <code>pydantic_schemaforms/rendering/layout_engine.py</code>, <code>examples/fastapi_example.py</code>, <code>tests/test_theme_hooks.py</code>, <code>tests/test_fastapi_example_smoke.py</code></p> </li> <li> <p>Runtime field registration surfaced (New)   Dynamically extending a <code>FormModel</code> is now supported via <code>FormModel.register_field()</code>, which wires the new <code>FieldInfo</code> into the schema cache and the validation stack by synthesizing a runtime subclass when necessary. Legacy <code>setattr(MyForm, name, Field(...))</code> still works for rendering, but the helper ensures <code>validate_form_data()</code> and HTMX live validation enforce the same constraints without manual plumbing.   Files: <code>pydantic_schemaforms/schema_form.py</code>, <code>pydantic_schemaforms/validation.py</code>, <code>tests/test_integration_workflow.py</code> TODO: The temporary <code>DynamicFormRuntime</code> created by <code>pydantic.create_model()</code> emits a <code>UserWarning</code> about shadowing parent attributes. If this becomes noisy, add a local <code>model_config = {\"ignored_types\": ...}</code> or suppress the warning via the helper before rebuilding the runtime model.</p> </li> <li> <p>Validation rule duplication (Resolved)   Validation is now canonical in <code>validation.py</code> (rules, <code>ValidationResponse</code>, convenience validators). <code>live_validation.py</code> consumes/re-exports without duplicating code. Added consolidation coverage (10 tests) for schema \u2192 live validator flow, convenience validators, and serialization.   Files: <code>pydantic_schemaforms/validation.py</code>, <code>pydantic_schemaforms/live_validation.py</code>, <code>pydantic_schemaforms/__init__.py</code>, <code>tests/test_validation_consolidation.py</code></p> </li> <li> <p>Input namespace still re-exports everything (Resolved)   The root package now exposes inputs via module-level <code>__getattr__</code>, delegating to a lazy-loading facade in <code>pydantic_schemaforms.inputs</code>. No wildcard imports remain, so importing <code>pydantic_schemaforms</code> does not instantiate every widget or template; consumers still get <code>from pydantic_schemaforms import TextInput</code> via the cached attribute. Future work can build on the same facade to document a plugin hook for third-party inputs.   Files: <code>pydantic_schemaforms/__init__.py</code>, <code>pydantic_schemaforms/inputs/__init__.py</code></p> </li> <li> <p>Integration facade duplicated across namespaces (Resolved)   The canonical sync/async helpers now live only in <code>integration/adapters.py</code>, <code>integration/sync.py</code>, and <code>integration/async_support.py</code>. The <code>integration.frameworks</code> package re-exports those implementations for legacy imports, and <code>FormIntegration.async_integration</code> was converted to a <code>@staticmethod</code> so the API is identical in both namespaces. Optional dependencies remain isolated via lazy imports, but there is now exactly one code path for validation + rendering logic.   Files: <code>pydantic_schemaforms/integration/__init__.py</code>, <code>pydantic_schemaforms/integration/adapters.py</code>, <code>pydantic_schemaforms/integration/frameworks/*</code></p> </li> <li> <p>Public sync/async \u201cone obvious way\u201d (Resolved)   Canonical entry points now exist and are exported from the root package:</p> </li> <li>Sync: <code>handle_form()</code></li> <li>Async: <code>handle_form_async()</code></li> </ul> <p>Legacy helpers (<code>handle_sync_form</code>, <code>handle_async_form</code>, <code>FormIntegration.*</code>) remain as compatibility wrappers.   Files: <code>pydantic_schemaforms/integration/adapters.py</code>, <code>pydantic_schemaforms/integration/__init__.py</code>, <code>pydantic_schemaforms/__init__.py</code>, <code>docs/quickstart.md</code>, <code>tests/test_integration.py</code></p> <ul> <li> <p>Theme/style contract centralized <code>RendererTheme</code> now includes concrete <code>FrameworkTheme</code> subclasses for Bootstrap/Material/plain plus <code>get_theme_for_framework</code>, and both enhanced + field renderers request classes/assets from the active theme before falling back to legacy configs. <code>FormStyle</code> registry now handles framework-level templates (including field-level chrome) and supports version-aware descriptors (e.g., <code>bootstrap:5</code>, <code>material:3</code>) with fallbacks to base framework/default.   Files: <code>pydantic_schemaforms/enhanced_renderer.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code>, <code>pydantic_schemaforms/rendering/field_renderer.py</code>, <code>pydantic_schemaforms/rendering/frameworks.py</code>, <code>pydantic_schemaforms/rendering/form_style.py</code></p> </li> <li> <p>Plugin hooks for inputs/layouts (NEW)   Input components can now be registered via <code>register_input_class()</code> and <code>register_inputs()</code> in <code>inputs/registry.py</code> with automatic cache invalidation. Layout renderers can be registered via <code>LayoutEngine.register_layout_renderer()</code> and referenced from form fields using <code>layout_handler</code> metadata. Both APIs support resettable state for testing. Docs page <code>docs/plugin_hooks.md</code> explains usage and packaging patterns.   Files: <code>pydantic_schemaforms/inputs/registry.py</code>, <code>pydantic_schemaforms/rendering/layout_engine.py</code>, <code>docs/plugin_hooks.md</code>, <code>tests/test_plugin_hooks.py</code></p> </li> </ul>"},{"location":"review/#testing-tooling-gaps","title":"Testing &amp; Tooling Gaps","text":"<ul> <li>\u2705 Renderer behavior E2E coverage (COMPLETED) \u2014 Added <code>tests/test_e2e_layouts_async.py</code> with 14 tests: unit tests for tab/accordion DOM structure, aria attributes, display state; integration tests for <code>LayoutDemonstrationForm</code> with nested fields and model lists; async equivalence tests. All passing.</li> <li>\u2705 CI/docs alignment (COMPLETED) \u2014 Documented <code>make tests</code> as single entry point in new <code>docs/testing_workflow.md</code> (comprehensive guide with test organization, linting rules, CI/CD integration, troubleshooting). Ruff now enabled in <code>.pre-commit-config.yaml</code> and enforced as part of <code>make tests</code> before pytest runs.</li> </ul>"},{"location":"review/#recommended-next-steps","title":"Recommended Next Steps","text":"<ol> <li>\u2705 Document unified validation engine (COMPLETED) \u2014 Created comprehensive <code>docs/validation_guide.md</code> (787 lines) with:</li> <li><code>ValidationResponse</code>, <code>FieldValidator</code>, <code>FormValidator</code>, and <code>ValidationSchema</code> API documentation</li> <li>Server-side validation patterns with <code>validate_form_data()</code> and custom rules</li> <li>Real-time HTMX validation with <code>LiveValidator</code> and <code>HTMXValidationConfig</code></li> <li>Cross-field validation examples (age consent, password matching, conditional fields)</li> <li>Convenience validators (<code>create_email_validator()</code>, <code>create_password_strength_validator()</code>)</li> <li>Complete end-to-end sync + HTMX flow example with FastAPI endpoints and HTML templates</li> <li>Testing patterns and Pydantic v2 deprecation resolution notes</li> <li> <p>References to layout-demo smoke test coverage and tab rendering verification</p> </li> <li> <p>\u2705 Suppress remaining expected deprecation warnings (COMPLETED) \u2014 Added <code>filterwarnings</code> to <code>[tool.pytest.ini_options]</code> in <code>pyproject.toml</code> to suppress intentional warnings: <code>form_layouts</code> deprecation notice (migration guidance), Pydantic JSON schema non-serializable defaults (informational), and Pydantic extra kwargs deprecation (handled in code). Result: test output reduced from 19 warnings to 1 in normal mode; warnings remain accessible via <code>pytest -W default</code>.</p> </li> <li> <p>\u2705 Field-level chrome routing (COMPLETED) \u2014 Extended <code>FormStyle</code> to support field-level help/error templating: Added <code>field_help</code> and <code>field_error</code> templates to <code>FormStyleTemplates</code> dataclass (15 slots total, up from 13), registered framework-specific versions for Bootstrap, Plain, and Material Design. Ready for field renderers to consume these templates; enables consistent field-level chrome across all frameworks without renderer edits.</p> </li> <li> <p>\u2705 Version-aware style variants (COMPLETED) \u2014 <code>FormStyle</code> descriptors accept framework + variant (e.g., <code>\"bootstrap:5\"</code>, <code>\"material:3\"</code>) with graceful fallbacks to the framework base and default style. Aliases registered for Bootstrap 5 and Material 3 reuse existing templates; lookup stays backward compatible.</p> </li> <li> <p>\u2705 Extension hooks for inputs/layouts (COMPLETED) \u2014 Plugin registration API added: <code>register_input_class()</code> / <code>register_inputs()</code> in <code>inputs/registry</code> with cache clearing, and <code>LayoutEngine.register_layout_renderer()</code> with metadata-driven dispatch. Documented in <code>docs/plugin_hooks.md</code> with examples and best practices.</p> </li> <li> <p>\u2705 Automated E2E coverage for layouts/async (COMPLETED) \u2014 Added comprehensive <code>tests/test_e2e_layouts_async.py</code> (14 tests) covering: unit tests for tab/accordion DOM structure, aria attributes, and display state; integration tests for <code>LayoutDemonstrationForm</code> tab/layout field rendering with nested content and model lists; async tests verifying <code>render_form_from_model_async()</code> produces identical HTML to sync path, handles errors gracefully, and supports concurrent rendering. All tests passing.</p> </li> <li> <p>\u2705 CI/docs alignment (COMPLETED) \u2014 Documented <code>make tests</code> as single entry point in new <code>docs/testing_workflow.md</code> (comprehensive guide with test organization, linting rules, CI/CD integration, troubleshooting). Ruff now enabled in <code>.pre-commit-config.yaml</code> and enforced as part of <code>make tests</code> before pytest runs. All 217+ tests passing with integrated linting.</p> </li> <li> <p>\u2705 Make asset delivery self-contained (Completed for HTMX + IMask + framework assets) \u2014 The default renderer output is offline-by-default.</p> <ul> <li>\u2705 HTMX is vendored and inlined by default; CDN mode is opt-in and pinned.</li> </ul> </li> <li> <p>\u2705 IMask is vendored (for SSN and other secure input types) and can be included explicitly.</p> <ul> <li>\u2705 Bootstrap + Materialize CSS/JS are vendored and can be emitted inline via <code>asset_mode=\"vendored\"</code> when framework assets are requested.</li> </ul> <p>Update workflow (implemented) - Vendoring and verification scripts/targets exist, and tests enforce \u201cno external URLs by default\u201d.   - <code>docs/assets.md</code> documents the <code>asset_mode</code> contract and the vendoring workflow.</p> </li> </ol> <p>Tooling note (important)   - Pre-commit should exclude vendored assets and generated artifacts (coverage/test reports, debug HTML) from whitespace/EOF fixers to keep checksum verification and <code>make tests</code> stable.</p> <ol> <li>\u2705 Define one canonical sync + one canonical async entry point (COMPLETED) \u2014 Canonical entry points exist and are documented:</li> <li>Sync: <code>handle_form()</code></li> <li>Async: <code>handle_form_async()</code></li> </ol> <p>Both are exported from <code>pydantic_schemaforms</code> and covered by integration tests.   Files: <code>pydantic_schemaforms/integration/adapters.py</code>, <code>pydantic_schemaforms/__init__.py</code>, <code>docs/quickstart.md</code>, <code>tests/test_integration.py</code></p> <ol> <li>\u2705 Add a first-class debug rendering mode (COMPLETED) \u2014 Implemented a <code>debug=True</code> option that wraps the form in a collapsed debug panel with tabs:</li> <li>Rendered output: raw HTML (including the CSS/JS assets block)</li> <li>Form/model source: Python source for the form class (best-effort via <code>inspect.getsource()</code>)</li> <li>Schema / validation: schema-derived constraints (field requirements, min/max, regex, etc.)</li> <li>Live payload: Real-time form data capture that updates as users type/interact with the form</li> </ol> <p>Implementation details:    - Debug panel is off by default and non-invasive (collapsed <code>&lt;details&gt;</code> element)    - JavaScript event listeners capture <code>input</code> and <code>change</code> events to update live payload    - Handles nested form data (model lists with <code>pets[0].name</code> notation)    - Proper checkbox handling (true/false instead of \"on\" or missing)    - Tab UI consistent across frameworks using inline styles/scripts    - Tests verify debug panel presence when enabled and absence by default    - FastAPI example updated to expose <code>?debug=1</code> query parameter on all form routes</p> <p>Files: <code>pydantic_schemaforms/enhanced_renderer.py</code> (debug panel builder), <code>pydantic_schemaforms/render_form.py</code> (debug flag forwarding), <code>tests/test_debug_mode.py</code> (2 tests), <code>examples/fastapi_example.py</code> (debug parameter on all routes)</p> <p>## Codebase Layout (Package Map)</p> <p>This section documents the git-tracked layout of the <code>pydantic_schemaforms/</code> package.</p> <p>Notes:</p> <ul> <li>Runtime-generated <code>__pycache__/</code> folders and <code>*.pyc</code> files are intentionally omitted here (they are not part of the source tree and should not be committed).</li> </ul> <p>### <code>pydantic_schemaforms/</code> (root package)</p> <ul> <li><code>pydantic_schemaforms/__init__.py</code> \u2014 Public package entry point (lazy exports) and top-level API surface.</li> <li><code>pydantic_schemaforms/enhanced_renderer.py</code> \u2014 Enhanced renderer pipeline (schema \u2192 fields \u2192 layout) with sync/async HTML entry points.</li> <li><code>pydantic_schemaforms/form_field.py</code> \u2014 <code>FormField</code> abstraction and higher-level field helpers aligned with the design vision.</li> <li><code>pydantic_schemaforms/form_layouts.py</code> \u2014 Legacy layout composition helpers (kept for compatibility; deprecated).</li> <li><code>pydantic_schemaforms/icon_mapping.py</code> \u2014 Framework icon mapping helpers (bootstrap/material icon name/class resolution).</li> <li><code>pydantic_schemaforms/input_types.py</code> \u2014 Input type constants, default mappings, and validation utilities for selecting HTML input types.</li> <li><code>pydantic_schemaforms/layout_base.py</code> \u2014 Shared base layout primitives used by the layout engine and renderer(s).</li> <li><code>pydantic_schemaforms/layouts.py</code> \u2014 Deprecated layout wrapper module (compatibility surface).</li> <li><code>pydantic_schemaforms/live_validation.py</code> \u2014 HTMX-oriented \u201clive validation\u201d plumbing and configuration.</li> <li><code>pydantic_schemaforms/model_list.py</code> \u2014 Rendering helpers for repeating/nested model lists.</li> <li><code>pydantic_schemaforms/modern_renderer.py</code> \u2014 \u201cModern\u201d renderer facade backed by the shared enhanced pipeline.</li> <li><code>pydantic_schemaforms/render_form.py</code> \u2014 Backwards-compatible rendering wrapper(s) for legacy entry points.</li> <li><code>pydantic_schemaforms/schema_form.py</code> \u2014 Pydantic-driven form model primitives (<code>FormModel</code>, <code>Field</code>, validator helpers, validation result types).</li> <li><code>pydantic_schemaforms/simple_material_renderer.py</code> \u2014 Minimal Material Design renderer implementation.</li> <li><code>pydantic_schemaforms/templates.py</code> \u2014 Python 3.14 template-string based templating helpers used throughout rendering.</li> <li><code>pydantic_schemaforms/validation.py</code> \u2014 Canonical validation rules/engine and serializable validation responses.</li> <li><code>pydantic_schemaforms/vendor_assets.py</code> \u2014 Vendoring/manifest helper utilities used to manage and verify shipped third-party assets.</li> <li><code>pydantic_schemaforms/version_check.py</code> \u2014 Python version checks (enforces Python 3.14+ assumptions like template strings).</li> </ul> <p>### <code>pydantic_schemaforms/assets/</code> (packaged assets)</p> <ul> <li><code>pydantic_schemaforms/assets/__init__.py</code> \u2014 Asset package marker.</li> <li><code>pydantic_schemaforms/assets/runtime.py</code> \u2014 Runtime helpers to load/inline assets and emit tags (vendored vs pinned CDN modes).</li> </ul> <p>#### <code>pydantic_schemaforms/assets/vendor/</code> (vendored third\u2011party assets)</p> <ul> <li><code>pydantic_schemaforms/assets/vendor/README.md</code> \u2014 Vendored asset policy and update workflow overview.</li> <li><code>pydantic_schemaforms/assets/vendor/vendor_manifest.json</code> \u2014 Pin list and SHA256 checksums for vendored assets (audit + verification).</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/bootstrap/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/bootstrap/bootstrap.min.css</code> \u2014 Vendored, minified Bootstrap CSS.</li> <li><code>pydantic_schemaforms/assets/vendor/bootstrap/bootstrap.bundle.min.js</code> \u2014 Vendored, minified Bootstrap JS bundle.</li> <li><code>pydantic_schemaforms/assets/vendor/bootstrap/LICENSE</code> \u2014 Upstream Bootstrap license text.</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/htmx/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/htmx/htmx.min.js</code> \u2014 Vendored, minified HTMX library.</li> <li><code>pydantic_schemaforms/assets/vendor/htmx/LICENSE</code> \u2014 Upstream HTMX license text.</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/imask/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/imask/imask.min.js</code> \u2014 Vendored, minified IMask library (used for masked inputs).</li> <li><code>pydantic_schemaforms/assets/vendor/imask/LICENSE</code> \u2014 Upstream IMask license text.</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/materialize/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/materialize/materialize.min.css</code> \u2014 Vendored, minified Materialize CSS.</li> <li><code>pydantic_schemaforms/assets/vendor/materialize/materialize.min.js</code> \u2014 Vendored, minified Materialize JS.</li> <li><code>pydantic_schemaforms/assets/vendor/materialize/LICENSE</code> \u2014 Upstream Materialize license text.</li> </ul> <p>### <code>pydantic_schemaforms/inputs/</code> (input components)</p> <ul> <li><code>pydantic_schemaforms/inputs/__init__.py</code> \u2014 Lazy-loading facade for input classes (keeps import cost low).</li> <li><code>pydantic_schemaforms/inputs/base.py</code> \u2014 Base input types, rendering utilities, and shared label/help/error builders.</li> <li><code>pydantic_schemaforms/inputs/datetime_inputs.py</code> \u2014 Date/time-related input components.</li> <li><code>pydantic_schemaforms/inputs/numeric_inputs.py</code> \u2014 Numeric/slider/range-related input components.</li> <li><code>pydantic_schemaforms/inputs/registry.py</code> \u2014 Runtime registry and discovery helpers for input components.</li> <li><code>pydantic_schemaforms/inputs/selection_inputs.py</code> \u2014 Select/checkbox/radio/toggle-related input components.</li> <li><code>pydantic_schemaforms/inputs/specialized_inputs.py</code> \u2014 Specialized inputs (file upload, color, hidden, csrf/honeypot, tags, etc.).</li> <li><code>pydantic_schemaforms/inputs/text_inputs.py</code> \u2014 Text-ish inputs (text, password, email, URL, phone, credit card, etc.).</li> </ul> <p>### <code>pydantic_schemaforms/integration/</code> (framework/application integration)</p> <ul> <li><code>pydantic_schemaforms/integration/__init__.py</code> \u2014 Integration facade with lazy exports of framework glue.</li> <li><code>pydantic_schemaforms/integration/adapters.py</code> \u2014 High-level sync/async integration entry points (<code>handle_form</code>, <code>handle_form_async</code>).</li> <li><code>pydantic_schemaforms/integration/async_support.py</code> \u2014 Framework-agnostic async request/validation helpers.</li> <li><code>pydantic_schemaforms/integration/builder.py</code> \u2014 Form builder utilities (prebuilt forms, page wrapper helpers, asset tag helpers).</li> <li><code>pydantic_schemaforms/integration/react.py</code> \u2014 React JSON schema form-oriented integration helpers.</li> <li><code>pydantic_schemaforms/integration/schema.py</code> \u2014 JSON/OpenAPI schema generation utilities.</li> <li><code>pydantic_schemaforms/integration/sync.py</code> \u2014 Framework-agnostic sync request/validation helpers.</li> <li><code>pydantic_schemaforms/integration/utils.py</code> \u2014 Shared utilities for integrations (type mapping, framework selection, validation conversion).</li> <li><code>pydantic_schemaforms/integration/vue.py</code> \u2014 Vue integration helpers.</li> </ul> <p>#### <code>pydantic_schemaforms/integration/frameworks/</code> (compat + legacy namespace)</p> <ul> <li><code>pydantic_schemaforms/integration/frameworks/__init__.py</code> \u2014 Namespace package for framework adapters.</li> <li><code>pydantic_schemaforms/integration/frameworks/adapters.py</code> \u2014 Compatibility shim re-exporting the canonical adapter API.</li> <li><code>pydantic_schemaforms/integration/frameworks/async_support.py</code> \u2014 Compatibility shim re-exporting async helpers.</li> <li><code>pydantic_schemaforms/integration/frameworks/sync.py</code> \u2014 Compatibility shim re-exporting sync helpers.</li> </ul> <p>### <code>pydantic_schemaforms/rendering/</code> (shared rendering engine)</p> <ul> <li><code>pydantic_schemaforms/rendering/__init__.py</code> \u2014 Shared rendering module namespace.</li> <li><code>pydantic_schemaforms/rendering/context.py</code> \u2014 Render context objects passed through renderers/layouts.</li> <li><code>pydantic_schemaforms/rendering/field_renderer.py</code> \u2014 Field-level rendering logic used by multiple renderers.</li> <li><code>pydantic_schemaforms/rendering/form_style.py</code> \u2014 <code>FormStyle</code> contract/registry that centralizes framework templates.</li> <li><code>pydantic_schemaforms/rendering/frameworks.py</code> \u2014 Framework configuration and input component mapping lookup.</li> <li><code>pydantic_schemaforms/rendering/layout_engine.py</code> \u2014 Layout primitives and the engine that renders composed layouts.</li> <li><code>pydantic_schemaforms/rendering/schema_parser.py</code> \u2014 Schema parsing/metadata extraction (pydantic model \u2192 render plan).</li> <li><code>pydantic_schemaforms/rendering/theme_assets.py</code> \u2014 Default CSS/JS snippets for layout-oriented components.</li> <li><code>pydantic_schemaforms/rendering/themes.py</code> \u2014 Theme strategies and framework themes (bootstrap/material/plain + embedded variants).</li> </ul> <p>## Beta Release Readiness Assessment</p> <p>### \u2705 Product Vision Alignment</p> <p>All six Design Rules (Non-Negotiables) are now fully satisfied:</p> <ol> <li> <p>Library ships the experience \u2705</p> <ul> <li>Default output is offline-by-default (vendored HTMX, IMask, Bootstrap, Materialize)</li> <li>CDN mode exists but is explicit opt-in and pinned to manifest versions</li> <li>All assets are checksummed and verified by tests</li> </ul> </li> <li> <p>Pydantic is the single source of truth \u2705</p> <ul> <li>Validation constraints, required/optional come from Pydantic schema/Field metadata</li> <li>UI configuration via <code>json_schema_extra</code> and form field helpers</li> <li>Schema generation sanitizes non-serializable objects</li> </ul> </li> <li> <p>One obvious way (sync + async) \u2705</p> <ul> <li>Canonical sync entry point: <code>handle_form()</code></li> <li>Canonical async entry point: <code>handle_form_async()</code></li> <li>Both exported from root package with integration test coverage</li> </ul> </li> <li> <p>Renderer outputs deterministic, self-contained HTML \u2705</p> <ul> <li>No global mutable state in renderer pipeline</li> <li>Deterministic output for same model + config</li> <li>Theme/style configuration is explicit</li> </ul> </li> <li> <p>Debug mode is optional and non-invasive \u2705</p> <ul> <li>Off by default (<code>debug=False</code>)</li> <li>Collapsed panel when enabled, never changes validation/rendering semantics</li> <li>Read-only views of: rendered HTML, model source, schema/validation, live payload</li> </ul> </li> <li> <p>Extensibility stays declarative \u2705</p> <ul> <li>Plugin registration via official registries (<code>register_input_class</code>, <code>register_layout_renderer</code>)</li> <li>Extension points compose with themes/styles</li> <li>Documented in <code>docs/plugin_hooks.md</code></li> </ul> </li> </ol> <p>### \u2705 Core Features Complete</p> <p>Rendering Pipeline:   - \u2705 Enhanced renderer with schema \u2192 fields \u2192 layout orchestration   - \u2705 Theme-driven styling (Bootstrap, Material Design, Plain, Default)   - \u2705 Field-level rendering with help/error chrome   - \u2705 Layout engine (Vertical, Horizontal, Tabbed, Accordion)   - \u2705 Model list support with add/remove functionality   - \u2705 Async rendering equivalence to sync path</p> <p>Validation:   - \u2705 Server-side validation via Pydantic   - \u2705 HTMX live validation support   - \u2705 Custom field validators   - \u2705 Cross-field validation patterns   - \u2705 Comprehensive validation guide documentation</p> <p>Integration:   - \u2705 Flask integration helpers   - \u2705 FastAPI integration helpers (async-first)   - \u2705 Framework-agnostic sync/async adapters   - \u2705 Working examples for both frameworks</p> <p>Developer Experience:   - \u2705 Debug mode with live payload inspection   - \u2705 Comprehensive test suite (250+ tests passing)   - \u2705 Documentation (quickstart, tutorial, validation guide, assets guide, plugin hooks, testing workflow)   - \u2705 Ruff linting + pre-commit hooks   - \u2705 CI/CD pipeline with coverage reporting</p> <p>### \u2705 Quality Metrics</p> <ul> <li>Test Coverage: 250+ tests passing (see <code>htmlcov/</code> for detailed report)</li> <li>Linting: Ruff enabled in pre-commit, zero linting errors</li> <li>Python Version: 3.14+ only (clearly documented)</li> <li>Dependencies: Minimal (pydantic&gt;=2.7, pydantic-extra-types[all]&gt;=2.10.6)</li> <li>Optional Dependencies: FastAPI and Flask marked as optional</li> </ul> <p>### \u26a0\ufe0f Known Limitations (Acceptable for Beta)</p> <ol> <li> <p>Dynamic field validation warning: Pydantic emits a <code>UserWarning</code> when using <code>FormModel.register_field()</code> due to <code>create_model()</code> behavior. This is cosmetic and doesn't affect functionality. Can be suppressed or improved in future releases.</p> </li> <li> <p>Material Design assets: Currently using Materialize CSS (older). Could be upgraded to Material Web Components or MUI in a future release, but current implementation is functional.</p> </li> <li> <p>Documentation completeness: Core features are documented, but some advanced patterns (custom input components, complex layouts) could benefit from additional examples.</p> </li> </ol> <p>### \ud83d\udccb Release Checklist</p> <ul> <li>\u2705 All design rules satisfied</li> <li>\u2705 Core features complete and tested</li> <li>\u2705 Debug mode implemented</li> <li>\u2705 Examples working (Flask + FastAPI)</li> <li>\u2705 Documentation covers essential workflows</li> <li>\u2705 Test suite passing (250+ tests)</li> <li>\u2705 Linting clean</li> <li>\u2705 Version marked as beta in <code>pyproject.toml</code> (25.11.3.beta)</li> <li>\u2705 README.md indicates beta status</li> <li>\u23f3 CHANGELOG.md updates (should document all changes since last release)</li> <li>\u23f3 Release notes prepared (features, breaking changes, migration guide)</li> </ul> <p>### \ud83c\udfaf Recommendation</p> <p>pydantic-schemaforms is ready for beta release with the following considerations:</p> <ol> <li>Update CHANGELOG.md to document all changes, new features, and breaking changes since the last release</li> <li>Prepare release notes highlighting:<ul> <li>Debug mode as a major new feature</li> <li>Offline-by-default asset strategy</li> <li>Theme-driven rendering system</li> <li>Plugin extensibility</li> <li>Python 3.14+ requirement (breaking change if upgrading from older versions)</li> </ul> </li> <li>Tag the release as <code>v25.11.3-beta</code> (or use current version scheme)</li> <li>Publish to PyPI with beta classifier</li> <li>Announce the beta in relevant communities (Reddit r/Python, Python Discord, etc.) and request feedback</li> </ol> <p>The library has strong architectural foundations, clear design principles, comprehensive test coverage, and working examples. The beta period should focus on:   - Gathering user feedback on API ergonomics   - Identifying edge cases in real-world usage   - Polishing documentation based on user questions   - Building community examples/templates</p> <p>Next Actions After Beta Release:   - Monitor issue tracker for bug reports and feature requests   - Gather feedback on debug mode usability   - Consider Material Web Components migration for v2.0   - Expand documentation with more advanced patterns   - Build gallery of community examples</p>"},{"location":"testing_workflow/","title":"Testing &amp; Contribution Workflow","text":"<p>This document describes the authoritative workflow for running tests, linting, and contributing to pydantic-schemaforms.</p>"},{"location":"testing_workflow/#single-entry-point-make-tests","title":"Single Entry Point: <code>make tests</code>","text":"<p>Use <code>make tests</code> (or <code>make test</code>) as the single, canonical command for running all quality checks before committing:</p> <pre><code>make tests\n</code></pre> <p>This runs: 1. Pre-commit hooks (Ruff linting + formatting, YAML/TOML checks, trailing whitespace) 2. Pytest (217+ tests covering validation, rendering, async, layouts, integration) 3. Coverage badge generation (summarizes test coverage) 4. Ruff linting (import ordering, style, deprecated patterns) \u2014 now enforced via pre-commit</p>"},{"location":"testing_workflow/#what-changed","title":"What Changed","text":"<ul> <li>Ruff is now enabled in <code>.pre-commit-config.yaml</code> and runs as part of <code>make tests</code></li> <li>Pre-commit hooks are mandatory before pytest runs; if linting fails, tests don't start</li> <li>No manual ruff invocation needed \u2014 it's automatic via pre-commit</li> </ul>"},{"location":"testing_workflow/#workflow","title":"Workflow","text":""},{"location":"testing_workflow/#before-committing","title":"Before Committing","text":"<pre><code># Full quality check\nmake tests\n\n# Or run individual steps if debugging:\nmake ruff          # Lint + format only\nmake isort         # Sort imports\nmake cleanup       # Run all formatters (isort + ruff + autoflake)\n</code></pre>"},{"location":"testing_workflow/#what-happens-in-make-tests","title":"What Happens in <code>make tests</code>","text":"<pre><code>\ud83d\udd0d Running pre-commit (ruff, formatting, yaml/toml checks)...\n\u2705 Pre-commit passed. Running pytest...\n[217 tests run]\n\ud83d\udcca Generating coverage and test badges...\n\u2728 Tests complete. Badges updated.\n</code></pre>"},{"location":"testing_workflow/#test-organization","title":"Test Organization","text":"<p>Tests are organized in <code>tests/</code> directory:</p> Test File Purpose Count <code>test_layout_demo_smoke.py</code> Tab/accordion initial render 3 <code>test_e2e_layouts_async.py</code> E2E: structure, integration, async 14 <code>test_plugin_hooks.py</code> Input/layout registration 2 <code>test_model_list_integration.py</code> Model list rendering &amp; validation 4 <code>test_validation_consolidation.py</code> Validation engine unification 10 <code>test_layouts.py</code> Layout classes (tabs, accordions, cards) 35+ ... Other units, integration, fixtures 150+"},{"location":"testing_workflow/#linting-rules-ruff","title":"Linting Rules (Ruff)","text":"<p>Ruff checks for: - Import ordering (<code>from __future__</code> first, stdlib, third-party, local) - Unused imports and variables - Deprecated patterns (old Pydantic v1 syntax) - Style (line length, unused code) - Type hints (basic checks)</p> <p>If Ruff finds issues, run: <pre><code>make ruff  # Auto-fix what it can\n</code></pre></p> <p>Then manually review any remaining issues and re-run <code>make tests</code>.</p>"},{"location":"testing_workflow/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li>Local: <code>make tests</code> validates code before pushing</li> <li>GitHub Actions (<code>.github/workflows/testing.yml</code>): Runs same checks on each PR</li> <li>Pre-commit: Enabled for all developers via <code>.pre-commit-config.yaml</code></li> </ul>"},{"location":"testing_workflow/#dependencies","title":"Dependencies","text":"<p>All test dependencies are in <code>requirements.txt</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Key packages: - <code>pytest</code> + <code>pytest-asyncio</code> + <code>pytest-cov</code> (testing) - <code>ruff</code> (linting + formatting) - <code>isort</code> (import sorting) - <code>genbadge</code> (coverage reporting) - <code>pre-commit</code> (hook management)</p>"},{"location":"testing_workflow/#troubleshooting","title":"Troubleshooting","text":""},{"location":"testing_workflow/#pre-commit-not-found","title":"\"pre-commit not found\"","text":"<pre><code>pip install pre-commit\n# or\nmake install\n</code></pre>"},{"location":"testing_workflow/#pytest-not-found","title":"\"pytest not found\"","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"testing_workflow/#ruff-keeps-failing-on-the-same-file","title":"Ruff keeps failing on the same file","text":"<p>Check what Ruff found: <pre><code>make ruff\n</code></pre></p> <p>If it's an actual issue (not auto-fixable), edit the file manually and re-run.</p>"},{"location":"testing_workflow/#running-only-pytest-skip-pre-commit","title":"Running only pytest (skip pre-commit)","text":"<pre><code>pytest tests/\n</code></pre> <p>\u26a0\ufe0f Not recommended \u2014 linting failures will catch issues in CI anyway.</p>"},{"location":"testing_workflow/#running-a-specific-test","title":"Running a specific test","text":"<pre><code>pytest tests/test_validation_consolidation.py -v\npytest tests/test_e2e_layouts_async.py::TestAsyncFormRendering::test_async_render_returns_same_html_as_sync -v\n</code></pre>"},{"location":"testing_workflow/#contributing","title":"Contributing","text":"<ol> <li>Create a branch: <code>git checkout -b feature/my-feature</code></li> <li>Make changes, add tests</li> <li>Run <code>make tests</code> to validate</li> <li>Commit and push</li> <li>Open a PR \u2014 CI will run the same checks</li> </ol> <p>All PRs must pass: - \u2705 Ruff linting - \u2705 Import ordering (isort) - \u2705 pytest (all tests) - \u2705 Coverage thresholds</p>"},{"location":"tutorial/","title":"Pydantic SchemaForms Tutorial: Your First Dynamic Web Form","text":"<p>Welcome to Pydantic SchemaForms! This tutorial will guide you through creating your first dynamic web form from scratch. We'll explain every step in detail, so don't worry if you're new to web forms or Python web development.</p>"},{"location":"tutorial/#what-youll-learn","title":"What You'll Learn","text":"<p>By the end of this tutorial, you'll understand: - How to create a basic web form using Pydantic SchemaForms - What each line of code does and why it's important - How forms work in web applications - How to handle user input safely</p>"},{"location":"tutorial/#what-you-need-before-starting","title":"What You Need Before Starting","text":"<p>Before we begin, make sure you have: - Python 3.14 or newer installed on your computer - Basic Python knowledge (variables, functions, imports) - A text editor (VS Code, PyCharm, or even Notepad++) - 5-10 minutes of your time</p> <p>You don't need to know Flask or web development - we'll explain everything!</p>"},{"location":"tutorial/#step-1-understanding-web-forms","title":"Step 1: Understanding Web Forms","text":"<p>Before we write code, let's understand what we're building. A web form is like a digital questionnaire that: 1. Shows input fields to users (text boxes, buttons, etc.) 2. Collects information when users type or click 3. Sends data to your Python program when submitted 4. Processes the data (save to database, send email, etc.)</p> <p>Think of it like a restaurant order form - customers fill it out, and the kitchen receives the order details.</p>"},{"location":"tutorial/#step-2-install-pydantic-schemaforms","title":"Step 2: Install Pydantic SchemaForms","text":"<p>First, we need to install the required packages. Open your terminal or command prompt and run:</p> <pre><code>pip install Flask pydantic-schemaforms\n</code></pre> <p>What this does: - Flask: A web framework that handles web requests and responses - pydantic-schemaforms: Our library that makes creating forms super easy</p>"},{"location":"tutorial/#step-3-create-your-first-file","title":"Step 3: Create Your First File","text":"<p>Create a new file called <code>my_first_form.py</code> and save it in a folder on your computer. This will contain all our code.</p>"},{"location":"tutorial/#step-4-build-your-first-form-line-by-line","title":"Step 4: Build Your First Form (Line by Line)","text":"<p>Copy this code into your <code>my_first_form.py</code> file. We'll explain every single line:</p> <pre><code># Import the tools we need\nfrom flask import Flask, render_template_string, request\nfrom pydantic_schemaforms import FormBuilder\n\n# Create a Flask web application\napp = Flask(__name__)\n\n# Define what happens when someone visits our website\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef hello_form():\n    # Check if someone submitted the form\n    if request.method == \"POST\":\n        # Get the name they typed and display it\n        user_name = request.form['name']\n        return f\"&lt;h1&gt;Hello {user_name}! Nice to meet you!&lt;/h1&gt;\"\n\n    # If they haven't submitted yet, show the form\n    # Build a simple form with one text input\n    form = FormBuilder().text_input(\"name\", \"What's your name?\").render()\n\n    # Create a complete HTML page with our form\n    html_page = \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My First Form&lt;/title&gt;\n        &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"container mt-5\"&gt;\n            &lt;h1&gt;Welcome to My First Form!&lt;/h1&gt;\n            &lt;p&gt;Please tell us your name:&lt;/p&gt;\n            {{ form | safe }}\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    return render_template_string(html_page, form=form)\n\n# Start the web server\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre> <p>Let's break down what each part does:</p>"},{"location":"tutorial/#line-1-2-import-statements","title":"Line 1-2: Import Statements","text":"<p><pre><code>from flask import Flask, render_template_string, request\nfrom pydantic_schemaforms import FormBuilder\n</code></pre> What this does: Brings in the tools we need - <code>Flask</code>: Creates our web application - <code>render_template_string</code>: Converts our HTML template into a webpage - <code>request</code>: Handles data coming from the form - <code>FormBuilder</code>: Our magic tool for creating forms easily</p>"},{"location":"tutorial/#line-4-5-create-the-web-app","title":"Line 4-5: Create the Web App","text":"<p><pre><code>app = Flask(__name__)\n</code></pre> What this does: Creates a new web application. Think of this as opening a new restaurant - you now have a place where customers (users) can visit.</p>"},{"location":"tutorial/#line-7-8-define-the-route","title":"Line 7-8: Define the Route","text":"<p><pre><code>@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef hello_form():\n</code></pre> What this does: - <code>@app.route(\"/\")</code>: Says \"when someone visits the main page of our website, run this function\" - <code>methods=[\"GET\", \"POST\"]</code>: Allows both viewing the page (GET) and submitting forms (POST) - <code>def hello_form():</code>: Creates a function that handles both showing and processing our form</p>"},{"location":"tutorial/#line-9-12-handle-form-submission","title":"Line 9-12: Handle Form Submission","text":"<p><pre><code>if request.method == \"POST\":\n    user_name = request.form['name']\n    return f\"&lt;h1&gt;Hello {user_name}! Nice to meet you!&lt;/h1&gt;\"\n</code></pre> What this does: - <code>if request.method == \"POST\":</code>: Checks if someone just submitted the form - <code>user_name = request.form['name']</code>: Gets the text they typed in the \"name\" field - <code>return f\"&lt;h1&gt;Hello {user_name}!...</code>: Shows a personalized greeting with their name</p>"},{"location":"tutorial/#line-14-16-create-the-form","title":"Line 14-16: Create the Form","text":"<p><pre><code>form = FormBuilder().text_input(\"name\", \"What's your name?\").render()\n</code></pre> What this does (this is the magic!): - <code>FormBuilder()</code>: Creates a new form builder (like getting a blank form template) - <code>.text_input(\"name\", \"What's your name?\")</code>: Adds a text input field   - <code>\"name\"</code>: The internal name for this field (how we'll reference it later)   - <code>\"What's your name?\"</code>: The label users will see - <code>.render()</code>: Converts our form description into actual HTML code</p>"},{"location":"tutorial/#line-18-32-create-the-webpage","title":"Line 18-32: Create the Webpage","text":"<p><pre><code>html_page = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n...\n{{ form | safe }}\n...\n\"\"\"\n</code></pre> What this does: - Creates a complete HTML webpage - <code>{{ form | safe }}</code>: Inserts our form into the page - The Bootstrap CSS makes everything look modern and professional</p>"},{"location":"tutorial/#line-34-return-the-page","title":"Line 34: Return the Page","text":"<p><pre><code>return render_template_string(html_page, form=form)\n</code></pre> What this does: Combines our HTML template with our form and sends it to the user's browser</p>"},{"location":"tutorial/#line-36-38-start-the-server","title":"Line 36-38: Start the Server","text":"<p><pre><code>if __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre> What this does: - Starts a web server on your computer - <code>debug=True</code>: Shows helpful error messages if something goes wrong</p>"},{"location":"tutorial/#step-5-run-your-form","title":"Step 5: Run Your Form","text":"<ol> <li>Save your <code>my_first_form.py</code> file</li> <li>Open terminal/command prompt in the same folder</li> <li>Run: <code>python my_first_form.py</code></li> <li>You'll see output like: <code>Running on http://127.0.0.1:5000</code></li> <li>Open your web browser and go to: <code>http://127.0.0.1:5000</code></li> </ol> <p>Congratulations! You just created your first web form! \ud83c\udf89</p>"},{"location":"tutorial/#step-6-test-your-form","title":"Step 6: Test Your Form","text":"<ol> <li>View the form: You should see a text input asking for your name</li> <li>Type your name: Enter your name in the text field</li> <li>Submit: Click the submit button</li> <li>See the result: You should see a personalized greeting!</li> </ol>"},{"location":"tutorial/#what-just-happened","title":"What Just Happened?","text":"<p>When you submitted the form: 1. Your browser sent your name to your Python program 2. Your program received it in the <code>request.form['name']</code> variable 3. Your program created a new webpage with your name in it 4. Your browser displayed the greeting</p> <p>This is the basic cycle of all web forms!</p>"},{"location":"tutorial/#step-7-understanding-the-formbuilder-magic","title":"Step 7: Understanding the FormBuilder Magic","text":"<p>The real magic happens in this line: <pre><code>form = FormBuilder().text_input(\"name\", \"What's your name?\").render()\n</code></pre></p> <p>Behind the scenes, this creates HTML like: <pre><code>&lt;form method=\"POST\"&gt;\n    &lt;div class=\"mb-3\"&gt;\n        &lt;label for=\"name\" class=\"form-label\"&gt;What's your name?&lt;/label&gt;\n        &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\"&gt;\n    &lt;/div&gt;\n    &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre></p> <p>But you don't have to write all that HTML yourself - Pydantic SchemaForms does it for you!</p>"},{"location":"tutorial/#step-8-add-more-fields-optional-challenge","title":"Step 8: Add More Fields (Optional Challenge)","text":"<p>Try modifying your form to ask for more information:</p> <pre><code>form = (FormBuilder()\n        .text_input(\"name\", \"What's your name?\")\n        .text_input(\"city\", \"What city are you from?\")\n        .number_input(\"age\", \"How old are you?\")\n        .render())\n</code></pre> <p>Then update your greeting to use all the information: <pre><code>if request.method == \"POST\":\n    name = request.form['name']\n    city = request.form['city']\n    age = request.form['age']\n    return f\"&lt;h1&gt;Hello {name}!&lt;/h1&gt;&lt;p&gt;It's nice to meet someone from {city} who is {age} years old!&lt;/p&gt;\"\n</code></pre></p>"},{"location":"tutorial/#bonus-compose-layouts-with-layoutcomposer","title":"Bonus: Compose Layouts with LayoutComposer","text":"<p>Once you are comfortable rendering a single form, you can arrange multiple snippets with the LayoutComposer API. This is the single public entry point for layout primitives and it lives next to the renderer internals.</p> <pre><code>from pydantic_schemaforms import FormBuilder\nfrom pydantic_schemaforms.rendering.layout_engine import LayoutComposer\n\ncontact_form = (FormBuilder()\n                .text_input(\"name\", \"What's your name?\")\n                .email_input(\"email\", \"Where can we reach you?\")\n                .render())\n\nprofile_card = LayoutComposer.card(\"Profile\", contact_form)\nsettings_card = LayoutComposer.card(\"Settings\", \"&lt;p&gt;Coming soon...&lt;/p&gt;\")\n\ntwo_column_layout = LayoutComposer.horizontal(\n    profile_card,\n    settings_card,\n    gap=\"2rem\",\n    justify_content=\"space-between\",\n)\n\nhtml = two_column_layout.render()\n</code></pre> <p>Every helper inside <code>LayoutComposer</code> returns a <code>BaseLayout</code> subclass, so you can freely nest them (e.g., a vertical stack of cards that contain grids). The legacy <code>pydantic_schemaforms.layouts</code> and <code>pydantic_schemaforms.form_layouts</code> modules now emit <code>DeprecationWarning</code>s and simply re-export this API for backward compatibility.</p>"},{"location":"tutorial/#theme-hooks-for-tabs-accordions-and-model-lists","title":"Theme Hooks for Tabs, Accordions, and Model Lists","text":"<p>The renderers no longer embed framework-specific HTML in random places. Instead, <code>RendererTheme</code> exposes hook methods so you can replace the shared assets in one spot:</p> <ul> <li><code>tab_component_assets()</code> and <code>accordion_component_assets()</code> return the CSS/JS that power tab/accordion interactions. The default implementation ships with Bootstrap-flavored styling, while <code>MaterialEmbeddedTheme</code> overrides both to emit Material Design tokens.</li> <li><code>render_layout_section()</code> controls how layout cards/tabs are wrapped, replacing the inline <code>CardLayout</code> markup when a theme wants its own chrome.</li> <li><code>render_model_list_container()</code> owns the wrapper for schema-driven and class-based <code>ModelListRenderer</code> instances (labels, help/error text, add buttons, etc.). Bootstrap/Material both call through this hook now, so future frameworks only need to provide a theme\u2014not duplicate renderer code.</li> <li><code>render_model_list_item()</code> owns the per-item chrome (card header, remove buttons, data attributes) for both schema-driven and imperative model lists. The renderer builds the inner field grid and hands the HTML off to this hook so your theme fully owns the markup users interact with.</li> </ul> <p>Creating a custom theme is straightforward:</p> <pre><code>from pydantic_schemaforms.enhanced_renderer import EnhancedFormRenderer\nfrom pydantic_schemaforms.rendering.themes import RendererTheme\n\n\nclass ShadcnTheme(RendererTheme):\n    name = \"shadcn\"\n\n    def tab_component_assets(self) -&gt; str:\n        return \"\"\"&lt;script&gt;/* shadcn tab switching */&lt;/script&gt;&lt;style&gt;.tab-button{font-family:var(--font-sans);}&lt;/style&gt;\"\"\"\n\n    def render_model_list_container(self, **kwargs) -&gt; str:\n        items_html = kwargs[\"items_html\"] or \"\"\n        return f\"\"\"\n        &lt;section class=\"shadcn-card\"&gt;\n            &lt;div class=\"shadcn-card__header\"&gt;\n                &lt;h3&gt;{kwargs['label']}&lt;/h3&gt;\n            &lt;/div&gt;\n            &lt;div class=\"shadcn-card__content\"&gt;{items_html}&lt;/div&gt;\n            &lt;div class=\"shadcn-card__footer\"&gt;\n                &lt;button class=\"btn\" data-target=\"{kwargs['field_name']}\"&gt;\n                    {kwargs['add_button_label']}\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/section&gt;\n        \"\"\"\n\n    def render_model_list_item(self, **kwargs) -&gt; str:\n        body_html = kwargs[\"body_html\"]\n        label = kwargs[\"model_label\"]\n        index = kwargs[\"index\"] + 1\n        return f\"\"\"\n        &lt;article class=\"shadcn-model-item\" data-index=\"{index}\"&gt;\n            &lt;header class=\"shadcn-model-item__header\"&gt;\n                &lt;h4&gt;{label} #{index}&lt;/h4&gt;\n                &lt;button type=\"button\" class=\"ghost-btn remove-item-btn\" data-index=\"{kwargs['index']}\"&gt;\n                    Remove\n                &lt;/button&gt;\n            &lt;/header&gt;\n            &lt;div class=\"shadcn-model-item__body\"&gt;{body_html}&lt;/div&gt;\n        &lt;/article&gt;\n        \"\"\"\n\n\n# Inject the theme while rendering\nrenderer = EnhancedFormRenderer(theme=ShadcnTheme())\nhtml = renderer.render_form_from_model(MyForm)\n</code></pre> <p>Because both <code>FieldRenderer</code> and <code>ModelListRenderer</code> read from the active theme first, this one class controls the chrome for schema-derived fields, nested layouts, and repeatable models. Tests should assert for the presence of your wrapper classes (e.g., <code>.shadcn-card</code>) to verify the integration.</p>"},{"location":"tutorial/#runtime-fields-and-new-ui-elements","title":"Runtime Fields and New UI Elements","text":"<p>Need to add fields after a form model is defined? Call <code>FormModel.register_field()</code> to describe the type and UI metadata at runtime. The helper keeps the renderer, the validation stack, and the live schema in sync:</p> <pre><code>from pydantic_schemaforms.schema_form import Field, FormModel\n\nclass ProfileForm(FormModel):\n    pass\n\nProfileForm.register_field(\n    \"nickname\",\n    annotation=str,\n    field=Field(..., ui_element=\"text\", min_length=3),\n)\n\nProfileForm.register_field(\n    \"terms_accepted\",\n    annotation=bool,\n    field=Field(False, ui_element=\"toggle\"),\n)\n</code></pre> <p><code>register_field</code> stores the new <code>FieldInfo</code>, rebuilds the runtime validator, and clears the schema cache, so <code>EnhancedFormRenderer</code>, <code>validate_form_data</code>, and the HTMX live validator all see the same set of fields. If you prefer to continue using <code>setattr(MyForm, name, Field(...))</code>, the renderer still picks up the new entries, but validation will only engage when the helper is used.</p> <p>Two new <code>ui_element</code> identifiers ship with this release:</p> <ul> <li><code>\"toggle\"</code> \u2013 renders the <code>ToggleSwitch</code> wrapper and maps to a checkbox value server-side.</li> <li><code>\"combobox\"</code> \u2013 renders the enhanced combo-box (text input backed by a datalist) so users can search or pick from known options.</li> </ul> <p>These map directly to the corresponding input components, so you can reference them in <code>Field(..., ui_element=\"toggle\")</code> or inside <code>ui_options</code> blocks without writing custom renderer glue.</p>"},{"location":"tutorial/#what-youve-learned","title":"What You've Learned","text":"<p>\ud83c\udfaf You now know how to: - Create a web application with Flask - Build forms using Pydantic SchemaForms' FormBuilder - Handle form submissions in Python - Display dynamic content based on user input</p> <p>\ud83e\udde0 Key concepts you understand: - Form fields: Different types of inputs (text, number, etc.) - Form submission: How data travels from browser to Python - Request handling: How to process incoming form data - Template rendering: How to create dynamic HTML pages</p>"},{"location":"tutorial/#whats-next","title":"What's Next?","text":"<p>Now that you understand the basics, you can: - Add validation to make sure users enter valid data - Use different input types like email, password, or dropdown menus - Style your forms with different CSS frameworks - Connect to databases to save form data permanently</p> <p>Ready to dive deeper? Check out:</p> <ul> <li>Quick Start</li> <li>Validation Guide</li> <li>Plugin Hooks</li> </ul>"},{"location":"tutorial/#troubleshooting","title":"Troubleshooting","text":"<p>Form not showing? - Make sure you saved the file - Check that you're visiting the right URL (http://127.0.0.1:5000)</p> <p>Errors when running? - Make sure you installed Flask and pydantic-schemaforms - Check that your Python indentation is correct</p> <p>Form submits but no greeting? - Make sure the field name in <code>request.form['name']</code> matches the field name in your FormBuilder</p> <p>Great job completing your first Pydantic SchemaForms tutorial!</p>"},{"location":"tutorial_fastapi/","title":"Tutorial: A Simple FastAPI Project","text":"<p>This tutorial walks through creating a small FastAPI app that renders a form from a Pydantic model using <code>pydantic-schemaforms</code>.</p> <p>It also explains when to use the sync handler (<code>handle_form</code>) vs the async handler (<code>handle_form_async</code>).</p>"},{"location":"tutorial_fastapi/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.14+</li> </ul>"},{"location":"tutorial_fastapi/#1-create-a-project","title":"1) Create a project","text":"<pre><code>mkdir schemaforms-fastapi-demo\ncd schemaforms-fastapi-demo\npython -m venv .venv\nsource .venv/bin/activate\n</code></pre>"},{"location":"tutorial_fastapi/#2-install-dependencies","title":"2) Install dependencies","text":"<pre><code>pip install \"pydantic-schemaforms[fastapi]\" uvicorn\n</code></pre>"},{"location":"tutorial_fastapi/#3-create-mainpy","title":"3) Create <code>main.py</code>","text":"<p>Create a file named <code>main.py</code>:</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom pydantic import BaseModel, EmailStr\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form_async\n\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n\n\napp = FastAPI(title=\"SchemaForms Demo\")\n\n\n@app.api_route(\"/user\", methods=[\"GET\", \"POST\"], response_class=HTMLResponse)\nasync def user_form(request: Request):\n    # Build a builder from your model (choose a framework theme).\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        # FastAPI form parsing is async.\n        form = await request.form()\n\n        # Validate + render response.\n        result = await handle_form_async(builder, submitted_data=dict(form))\n\n        # On success, result contains parsed/validated data.\n        if result.get(\"success\"):\n            return f\"Saved: {result['data']}\"\n\n        # On failure, you typically re-render the form (with errors).\n        return result[\"form_html\"]\n\n    # Initial render.\n    result = await handle_form_async(builder)\n    return result[\"form_html\"]\n</code></pre>"},{"location":"tutorial_fastapi/#4-run-the-server","title":"4) Run the server","text":"<pre><code>uvicorn main:app --reload\n</code></pre> <p>Open http://127.0.0.1:8000/user</p>"},{"location":"tutorial_fastapi/#sync-vs-async-whats-the-difference","title":"Sync vs Async (what\u2019s the difference?)","text":""},{"location":"tutorial_fastapi/#handle_form-sync","title":"<code>handle_form()</code> (sync)","text":"<p>Use <code>handle_form(builder, ...)</code> when your web framework is synchronous (WSGI) and you already have submitted data as a plain <code>dict</code>.</p> <p>Typical environments:</p> <ul> <li>Flask / Django (classic request/response)</li> <li>CLI apps or scripts that validate a dict</li> </ul> <p>Example (Flask):</p> <pre><code>from flask import Flask, request\nfrom pydantic import BaseModel, EmailStr\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form\n\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n\n\napp = Flask(__name__)\n\n\n@app.route(\"/user\", methods=[\"GET\", \"POST\"])\ndef user_form():\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        result = handle_form(builder, submitted_data=request.form.to_dict())\n        if result.get(\"success\"):\n            return f\"Saved: {result['data']}\"\n        return result[\"form_html\"]\n\n    return handle_form(builder)[\"form_html\"]\n</code></pre>"},{"location":"tutorial_fastapi/#handle_form_async-async","title":"<code>handle_form_async()</code> (async)","text":"<p>Use <code>handle_form_async(builder, ...)</code> when you are in an async runtime (ASGI) and you are already <code>await</code>-ing things (like <code>request.form()</code> in FastAPI/Starlette).</p> <p>Typical environments:</p> <ul> <li>FastAPI / Starlette</li> <li>Any async stack where you want to keep the request handler non-blocking</li> </ul>"},{"location":"tutorial_fastapi/#important-fastapi-note","title":"Important FastAPI note","text":"<p>FastAPI\u2019s <code>Request.form()</code> is async, so the most natural implementation is an <code>async def</code> route and <code>handle_form_async()</code>.</p> <p>If you already have a <code>dict</code> of submitted data (for example from a different parsing path), you can still call <code>handle_form()</code> inside an <code>async def</code> route \u2014 but the moment you need to <code>await</code> request parsing, you\u2019ll generally prefer the async handler for consistency.</p>"},{"location":"tutorial_fastapi/#next-steps","title":"Next steps","text":"<ul> <li>Learn about asset delivery (<code>asset_mode</code>) in <code>docs/assets.md</code></li> <li>See the broader integration pattern in <code>docs/quickstart.md</code></li> </ul>"},{"location":"validation_guide/","title":"Unified Validation Engine Guide","text":"<p>Complete guide to validation in pydantic-schemaforms: server-side, real-time HTMX, and cross-field patterns.</p>"},{"location":"validation_guide/#overview","title":"Overview","text":"<p>The pydantic-schemaforms validation system is consolidated into a single, unified engine that works seamlessly across: - Server-side validation via <code>validate_form_data()</code> and <code>FormValidator</code> - Real-time HTMX validation via <code>LiveValidator</code> and field-level validators - Cross-field validation via form-level rules - Convenience validators for common patterns (email, password strength)</p> <p>All validation rules live in <code>pydantic_schemaforms/validation.py</code>, re-exported from <code>pydantic_schemaforms/live_validation.py</code> for convenience, eliminating code duplication and ensuring consistency across all validation flows.</p>"},{"location":"validation_guide/#core-concepts","title":"Core Concepts","text":""},{"location":"validation_guide/#validationresponse","title":"ValidationResponse","text":"<p>The canonical response object for all validation operations (server-side or HTMX):</p> <pre><code>from pydantic_schemaforms import ValidationResponse\n\nresponse = ValidationResponse(\n    field_name=\"email\",\n    is_valid=True,\n    errors=[],                          # List of error messages\n    warnings=[],                        # List of warnings (non-blocking)\n    suggestions=[\"Example: user@example.com\"],  # Helpful hints\n    value=\"user@example.com\",           # The validated value\n    formatted_value=\"user@example.com\"  # Optionally formatted (e.g., lowercase)\n)\n\n# Serialize for HTMX responses\njson_str = response.to_json()\ndict_response = response.to_dict()\n</code></pre>"},{"location":"validation_guide/#validationschema-fieldvalidator","title":"ValidationSchema &amp; FieldValidator","text":"<p>Build reusable validation schemas from individual field validators:</p> <pre><code>from pydantic_schemaforms.validation import ValidationSchema, FieldValidator\n\n# Create a schema with multiple fields\nschema = ValidationSchema()\n\n# Add field validators\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nschema.add_field(email_validator)\n\npassword_validator = FieldValidator(\"password\")\npassword_validator.add_rule(\n    LengthRule(min=8, message=\"Minimum 8 characters required\")\n)\nschema.add_field(password_validator)\n\n# Build HTMX live validator from schema\nlive_validator = schema.build_live_validator()\n</code></pre>"},{"location":"validation_guide/#formvalidator","title":"FormValidator","text":"<p>Validate entire forms with both field-level and cross-field rules:</p> <pre><code>from pydantic_schemaforms.validation import FormValidator\n\nform_validator = FormValidator()\n\n# Add field validators\nform_validator.field(\"age\").add_rule(NumericRangeRule(min=0, max=150))\nform_validator.field(\"email\").add_rule(EmailRule())\n\n# Add cross-field validation\ndef validate_age_and_consent(data):\n    age = data.get(\"age\")\n    consent = data.get(\"parental_consent\")\n\n    if age is not None and age &lt; 18 and not consent:\n        return False, {\n            \"parental_consent\": [\"Parental consent required for users under 18\"]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_age_and_consent)\n\n# Validate form data\nis_valid, errors = form_validator.validate({\n    \"age\": 16,\n    \"email\": \"teen@example.com\",\n    \"parental_consent\": False\n})\n</code></pre>"},{"location":"validation_guide/#server-side-validation","title":"Server-Side Validation","text":""},{"location":"validation_guide/#using-validate_form_data","title":"Using validate_form_data()","text":"<p>For simple synchronous validation against a Pydantic <code>FormModel</code>:</p> <pre><code>from pydantic_schemaforms import FormModel, FormField, validate_form_data\n\nclass RegistrationForm(FormModel):\n    username: str = FormField(\n        title=\"Username\",\n        min_length=3,\n        max_length=20\n    )\n    email: str = FormField(\n        title=\"Email Address\",\n        input_type=\"email\"\n    )\n    password: str = FormField(\n        title=\"Password\",\n        input_type=\"password\",\n        min_length=8\n    )\n\n# Validate incoming form data\nresult = validate_form_data(RegistrationForm, {\n    \"username\": \"alice\",\n    \"email\": \"alice@example.com\",\n    \"password\": \"SecurePass123!\"\n})\n\nif result.is_valid:\n    print(f\"Valid! Data: {result.data}\")\nelse:\n    print(f\"Invalid! Errors: {result.errors}\")\n    # Result has: result.is_valid, result.data, result.errors\n</code></pre>"},{"location":"validation_guide/#using-formvalidator-with-pydantic-models","title":"Using FormValidator with Pydantic Models","text":"<p>For validation with additional custom rules:</p> <pre><code>from pydantic_schemaforms.validation import FormValidator\n\nform_validator = FormValidator()\nform_validator.field(\"username\").add_rule(LengthRule(min=3, max=20))\nform_validator.field(\"email\").add_rule(EmailRule())\nform_validator.field(\"password\").add_rule(LengthRule(min=8))\n\n# Validate and get results\nis_valid, errors = form_validator.validate({\n    \"username\": \"alice\",\n    \"email\": \"alice@example.com\",\n    \"password\": \"SecurePass123!\"\n})\n\n# Also validate against Pydantic model\nis_valid, errors = form_validator.validate_pydantic_model(\n    RegistrationForm,\n    request_data\n)\n</code></pre>"},{"location":"validation_guide/#real-time-htmx-validation","title":"Real-Time HTMX Validation","text":""},{"location":"validation_guide/#livevalidator-setup","title":"LiveValidator Setup","text":"<p>Use <code>LiveValidator</code> for server-side validation triggered via HTMX on blur/change events:</p> <pre><code>from pydantic_schemaforms.live_validation import LiveValidator, HTMXValidationConfig\nfrom pydantic_schemaforms.validation import FieldValidator, EmailRule\n\n# Configure HTMX behavior\nconfig = HTMXValidationConfig(\n    validate_on_blur=True,           # Validate when field loses focus\n    validate_on_input=False,         # Don't validate on every keystroke\n    validate_on_change=True,         # Validate when value changes\n    debounce_ms=300,                 # Wait 300ms before validation request\n    show_success_indicators=True,    # Visual feedback on valid input\n    show_warnings=True,              # Display warnings\n    show_suggestions=True,           # Show helpful hints\n    success_class=\"is-valid\",        # Bootstrap/custom CSS classes\n    error_class=\"is-invalid\",\n    warning_class=\"has-warning\",\n    loading_class=\"is-validating\"\n)\n\nlive_validator = LiveValidator(config)\n\n# Register field validators\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nlive_validator.register_field_validator(email_validator)\n\npassword_validator = FieldValidator(\"password\")\npassword_validator.add_rule(LengthRule(min=8))\nlive_validator.register_field_validator(password_validator)\n</code></pre>"},{"location":"validation_guide/#html-integration-with-htmx","title":"HTML Integration with HTMX","text":"<p>In your template, set up HTMX triggers for real-time validation:</p> <pre><code>&lt;!-- Form field with HTMX validation --&gt;\n&lt;input\n    type=\"email\"\n    name=\"email\"\n    id=\"email\"\n    class=\"form-control\"\n    placeholder=\"you@example.com\"\n    hx-post=\"/validate/email\"\n    hx-trigger=\"blur, change delay:300ms\"\n    hx-target=\"#email-feedback\"\n    hx-swap=\"outerHTML\"\n/&gt;\n\n&lt;!-- Validation feedback container --&gt;\n&lt;div id=\"email-feedback\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"validation_guide/#fastapi-endpoint-for-htmx-validation","title":"FastAPI Endpoint for HTMX Validation","text":"<pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom pydantic_schemaforms.live_validation import LiveValidator\nfrom pydantic_schemaforms.validation import FieldValidator, EmailRule\n\napp = FastAPI()\nlive_validator = LiveValidator()\n\n# Register validators\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nlive_validator.register_field_validator(email_validator)\n\n@app.post(\"/validate/email\", response_class=HTMLResponse)\nasync def validate_email(request: Request):\n    data = await request.form()\n    value = data.get(\"email\", \"\")\n\n    # Get validator for this field\n    validator = live_validator.get_field_validator(\"email\")\n    response = validator.validate(value)\n\n    # Render feedback HTML\n    if response.is_valid:\n        return f\"\"\"\n        &lt;div id=\"email-feedback\" class=\"valid-feedback\"&gt;\n            \u2713 Email looks good\n        &lt;/div&gt;\n        \"\"\"\n    else:\n        errors_html = \"\".join([f\"&lt;li&gt;{e}&lt;/li&gt;\" for e in response.errors])\n        return f\"\"\"\n        &lt;div id=\"email-feedback\" class=\"invalid-feedback\"&gt;\n            &lt;ul&gt;{errors_html}&lt;/ul&gt;\n        &lt;/div&gt;\n        \"\"\"\n</code></pre>"},{"location":"validation_guide/#building-livevalidator-from-validationschema","title":"Building LiveValidator from ValidationSchema","text":"<p>Automatically convert a schema to HTMX-ready validators:</p> <pre><code>from pydantic_schemaforms.validation import ValidationSchema, FieldValidator, EmailRule\n\nschema = ValidationSchema()\n\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nschema.add_field(email_validator)\n\n# Create HTMX live validator from schema\nlive_validator = schema.build_live_validator()\n\n# Now use live_validator in HTMX endpoints\n</code></pre>"},{"location":"validation_guide/#cross-field-validation","title":"Cross-Field Validation","text":""},{"location":"validation_guide/#form-level-rules","title":"Form-Level Rules","text":"<p>Validate fields that depend on other fields:</p> <pre><code>from pydantic_schemaforms.validation import FormValidator\n\nform_validator = FormValidator()\n\n# Individual field rules\nform_validator.field(\"age\").add_rule(NumericRangeRule(min=0, max=150))\nform_validator.field(\"parental_consent\").add_rule(RequiredRule())\n\n# Cross-field validation\ndef validate_minor_consent(data):\n    \"\"\"Minors must have parental consent.\"\"\"\n    age = data.get(\"age\")\n    consent = data.get(\"parental_consent\")\n\n    if age is not None and age &lt; 18 and not consent:\n        return False, {\n            \"parental_consent\": [\n                \"Parental consent is required for users under 18 years old\"\n            ]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_minor_consent)\n\n# Validate returns both field and cross-field errors\nis_valid, errors = form_validator.validate({\n    \"age\": 16,\n    \"parental_consent\": False\n})\n\n# errors = {\"parental_consent\": [\"Parental consent is required...\"]}\n</code></pre>"},{"location":"validation_guide/#conditional-field-validation","title":"Conditional Field Validation","text":"<p>Validate a field only if another field has a certain value:</p> <pre><code>def validate_emergency_contact(data):\n    \"\"\"Emergency contact required if no direct phone provided.\"\"\"\n    has_phone = bool(data.get(\"phone\"))\n    has_emergency_contact = bool(data.get(\"emergency_contact\"))\n\n    if not has_phone and not has_emergency_contact:\n        return False, {\n            \"emergency_contact\": [\n                \"Either a phone number or emergency contact is required\"\n            ]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_emergency_contact)\n</code></pre>"},{"location":"validation_guide/#password-matching-validation","title":"Password Matching Validation","text":"<pre><code>def validate_passwords_match(data):\n    \"\"\"Ensure password and confirm_password match.\"\"\"\n    password = data.get(\"password\", \"\")\n    confirm = data.get(\"confirm_password\", \"\")\n\n    if password and confirm and password != confirm:\n        return False, {\n            \"confirm_password\": [\"Passwords do not match\"]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_passwords_match)\n</code></pre>"},{"location":"validation_guide/#convenience-validators","title":"Convenience Validators","text":""},{"location":"validation_guide/#email-validator","title":"Email Validator","text":"<pre><code>from pydantic_schemaforms.validation import create_email_validator\n\nemail_validator = create_email_validator()\n\nresponse = email_validator(\"user@example.com\")\n# ValidationResponse(field_name=\"email\", is_valid=True, ...)\n\nresponse = email_validator(\"invalid-email\")\n# ValidationResponse(\n#     field_name=\"email\",\n#     is_valid=False,\n#     errors=[\"Please enter a valid email address\"],\n#     suggestions=[\"Example: user@example.com\"],\n#     value=\"invalid-email\"\n# )\n</code></pre>"},{"location":"validation_guide/#password-strength-validator","title":"Password Strength Validator","text":"<pre><code>from pydantic_schemaforms.validation import create_password_strength_validator\n\npassword_validator = create_password_strength_validator(min_length=8)\n\nresponse = password_validator(\"WeakPass\")\n# ValidationResponse(\n#     field_name=\"password\",\n#     is_valid=False,\n#     errors=[\"Password must be at least 8 characters long\"],\n#     warnings=[\n#         \"Password should contain at least one uppercase letter\",\n#         \"Password should contain at least one number\"\n#     ],\n#     suggestions=[\n#         \"Add an uppercase letter (A-Z)\",\n#         \"Add a number (0-9)\"\n#     ],\n#     value=\"WeakPass\"\n# )\n\nresponse = password_validator(\"SecurePass123!\")\n# ValidationResponse(field_name=\"password\", is_valid=True, ...)\n</code></pre>"},{"location":"validation_guide/#common-validation-rules","title":"Common Validation Rules","text":""},{"location":"validation_guide/#built-in-rules","title":"Built-in Rules","text":"<p>The validation system includes pre-built rules for common patterns:</p> Rule Purpose Example <code>RequiredRule()</code> Field must have a value Required name field <code>LengthRule(min, max)</code> String length constraints 3\u201320 char username <code>EmailRule()</code> Valid email format Email field <code>PhoneRule()</code> Valid phone number Phone field <code>NumericRangeRule(min, max)</code> Numeric value range Age 0\u2013150 <code>DateRangeRule(min_date, max_date)</code> Date within range Future date only <code>RegexRule(pattern)</code> Custom regex pattern Custom format validation <code>CustomRule(func)</code> Custom validation function Complex logic"},{"location":"validation_guide/#example-complete-field-validation","title":"Example: Complete Field Validation","text":"<pre><code>from pydantic_schemaforms.validation import (\n    FieldValidator,\n    EmailRule,\n    LengthRule,\n    NumericRangeRule\n)\n\n# Email field validator\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(RequiredRule(\"Email is required\"))\nemail_validator.add_rule(EmailRule())\n\n# Username field validator\nusername_validator = FieldValidator(\"username\")\nusername_validator.add_rule(RequiredRule(\"Username is required\"))\nusername_validator.add_rule(LengthRule(min=3, max=20, message=\"3\u201320 characters\"))\n\n# Age field validator\nage_validator = FieldValidator(\"age\")\nage_validator.add_rule(NumericRangeRule(min=13, max=150, message=\"Must be 13+\"))\n\n# Use in form validator\nform_validator = FormValidator()\nform_validator.field(\"email\").add_rule(EmailRule())\nform_validator.field(\"username\").add_rule(LengthRule(min=3, max=20))\nform_validator.field(\"age\").add_rule(NumericRangeRule(min=13, max=150))\n</code></pre>"},{"location":"validation_guide/#sync-htmx-validation-flow","title":"Sync + HTMX Validation Flow","text":""},{"location":"validation_guide/#end-to-end-example","title":"End-to-End Example","text":"<p>Here's a complete registration form with both server validation and real-time HTMX feedback:</p>"},{"location":"validation_guide/#1-define-form-model","title":"1. Define Form Model","text":"<pre><code>from pydantic_schemaforms import FormModel, FormField\n\nclass RegistrationForm(FormModel):\n    username: str = FormField(\n        title=\"Username\",\n        input_type=\"text\",\n        min_length=3,\n        max_length=20,\n        help_text=\"3\u201320 alphanumeric characters\"\n    )\n\n    email: str = FormField(\n        title=\"Email Address\",\n        input_type=\"email\",\n        help_text=\"We'll send a confirmation link\"\n    )\n\n    password: str = FormField(\n        title=\"Password\",\n        input_type=\"password\",\n        min_length=8,\n        help_text=\"Must be at least 8 characters\"\n    )\n\n    confirm_password: str = FormField(\n        title=\"Confirm Password\",\n        input_type=\"password\",\n        help_text=\"Re-enter your password\"\n    )\n\n    age: int = FormField(\n        title=\"Age\",\n        input_type=\"number\",\n        ge=13,\n        le=150,\n        help_text=\"Must be 13 or older\"\n    )\n</code></pre>"},{"location":"validation_guide/#2-set-up-validation","title":"2. Set Up Validation","text":"<pre><code>from pydantic_schemaforms.validation import (\n    FormValidator,\n    FieldValidator,\n    EmailRule,\n    LengthRule,\n    NumericRangeRule\n)\n\n# Create form validator with all rules\nform_validator = FormValidator()\n\n# Field validators\nform_validator.field(\"username\").add_rule(\n    LengthRule(min=3, max=20, message=\"3\u201320 characters\")\n)\nform_validator.field(\"email\").add_rule(EmailRule())\nform_validator.field(\"password\").add_rule(\n    LengthRule(min=8, message=\"Minimum 8 characters\")\n)\nform_validator.field(\"age\").add_rule(\n    NumericRangeRule(min=13, max=150, message=\"Must be 13+\")\n)\n\n# Cross-field rules\ndef validate_passwords_match(data):\n    if data.get(\"password\") != data.get(\"confirm_password\"):\n        return False, {\"confirm_password\": [\"Passwords do not match\"]}\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_passwords_match)\n\n# Live validator for HTMX\nlive_validator = form_validator.build_live_validator()\n</code></pre>"},{"location":"validation_guide/#3-fastapi-endpoints","title":"3. FastAPI Endpoints","text":"<pre><code>from fastapi import FastAPI, Request, Form\nfrom fastapi.responses import HTMLResponse, JSONResponse\nfrom pydantic_schemaforms import render_form, validate_form_data\n\napp = FastAPI()\n\n@app.get(\"/register\")\ndef show_registration():\n    form = RegistrationForm()\n    return render_form(form, framework=\"bootstrap\")\n\n@app.post(\"/register\")\nasync def handle_registration(request: Request):\n    # Get form data\n    form_data = await request.form()\n\n    # Server-side validation\n    result = validate_form_data(RegistrationForm, dict(form_data))\n\n    if result.is_valid:\n        # Process registration\n        return JSONResponse({\n            \"success\": True,\n            \"message\": \"Registration successful!\"\n        })\n    else:\n        # Return form with errors\n        form = RegistrationForm()\n        return render_form(\n            form,\n            framework=\"bootstrap\",\n            errors=result.errors\n        )\n\n# HTMX validation endpoints\n@app.post(\"/validate/username\")\nasync def validate_username(request: Request):\n    data = await request.form()\n    value = data.get(\"username\", \"\")\n\n    validator = form_validator.field(\"username\")\n    response = validator.validate(value)\n\n    if response.is_valid:\n        return HTMLResponse(\n            f'&lt;div class=\"valid-feedback\"&gt;\u2713 Available&lt;/div&gt;'\n        )\n    else:\n        errors = \"\".join([f\"&lt;li&gt;{e}&lt;/li&gt;\" for e in response.errors])\n        return HTMLResponse(\n            f'&lt;div class=\"invalid-feedback\"&gt;&lt;ul&gt;{errors}&lt;/ul&gt;&lt;/div&gt;'\n        )\n\n@app.post(\"/validate/email\")\nasync def validate_email(request: Request):\n    data = await request.form()\n    value = data.get(\"email\", \"\")\n\n    response = form_validator.field(\"email\").validate(value)\n\n    if response.is_valid:\n        return HTMLResponse(\n            f'&lt;div class=\"valid-feedback\"&gt;\u2713 Valid email&lt;/div&gt;'\n        )\n    else:\n        errors = \"\".join([f\"&lt;li&gt;{e}&lt;/li&gt;\" for e in response.errors])\n        return HTMLResponse(\n            f'&lt;div class=\"invalid-feedback\"&gt;&lt;ul&gt;{errors}&lt;/ul&gt;&lt;/div&gt;'\n        )\n</code></pre>"},{"location":"validation_guide/#4-html-template","title":"4. HTML Template","text":"<pre><code>&lt;form hx-post=\"/register\" hx-target=\"#form-result\"&gt;\n    &lt;!-- Username field with HTMX validation --&gt;\n    &lt;div class=\"form-group\"&gt;\n        &lt;label for=\"username\"&gt;Username&lt;/label&gt;\n        &lt;input\n            type=\"text\"\n            id=\"username\"\n            name=\"username\"\n            class=\"form-control\"\n            placeholder=\"3\u201320 characters\"\n            hx-post=\"/validate/username\"\n            hx-trigger=\"blur, change delay:300ms\"\n            hx-target=\"#username-feedback\"\n            hx-swap=\"outerHTML\"\n        /&gt;\n        &lt;div id=\"username-feedback\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;!-- Email field with HTMX validation --&gt;\n    &lt;div class=\"form-group\"&gt;\n        &lt;label for=\"email\"&gt;Email Address&lt;/label&gt;\n        &lt;input\n            type=\"email\"\n            id=\"email\"\n            name=\"email\"\n            class=\"form-control\"\n            placeholder=\"you@example.com\"\n            hx-post=\"/validate/email\"\n            hx-trigger=\"blur, change delay:300ms\"\n            hx-target=\"#email-feedback\"\n            hx-swap=\"outerHTML\"\n        /&gt;\n        &lt;div id=\"email-feedback\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;!-- Other fields... --&gt;\n\n    &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Register&lt;/button&gt;\n    &lt;div id=\"form-result\"&gt;&lt;/div&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"validation_guide/#testing-your-validators","title":"Testing Your Validators","text":"<p>The test suite includes comprehensive coverage. Use these patterns in your tests:</p> <pre><code>import pytest\nfrom pydantic_schemaforms.validation import (\n    FormValidator,\n    FieldValidator,\n    EmailRule,\n    ValidationResponse\n)\n\ndef test_email_validation():\n    email_validator = FieldValidator(\"email\")\n    email_validator.add_rule(EmailRule())\n\n    # Valid email\n    response = email_validator.validate(\"user@example.com\")\n    assert response.is_valid\n    assert response.errors == []\n\n    # Invalid email\n    response = email_validator.validate(\"not-an-email\")\n    assert not response.is_valid\n    assert len(response.errors) &gt; 0\n\ndef test_cross_field_validation():\n    form_validator = FormValidator()\n\n    def validate_passwords(data):\n        if data.get(\"password\") != data.get(\"confirm\"):\n            return False, {\"confirm\": [\"Passwords don't match\"]}\n        return True, {}\n\n    form_validator.add_cross_field_rule(validate_passwords)\n\n    is_valid, errors = form_validator.validate({\n        \"password\": \"secret\",\n        \"confirm\": \"different\"\n    })\n\n    assert not is_valid\n    assert \"confirm\" in errors\n</code></pre>"},{"location":"validation_guide/#layout-demo-tab-rendering-verification","title":"Layout Demo &amp; Tab Rendering Verification","text":"<p>The <code>tests/test_layout_demo_smoke.py</code> smoke test verifies that initial tab content renders correctly for both Bootstrap and Material frameworks:</p> <pre><code>def test_layout_demo_bootstrap_initial_tab_renders():\n    \"\"\"Verify Bootstrap tabs show initial tab content.\"\"\"\n    response = client.get(\"/layouts\")\n    assert response.status_code == 200\n    assert \"Tab 1 Content\" in response.text\n    # Assert tab buttons exist\n    assert 'class=\"nav-link active\"' in response.text\n\ndef test_layout_demo_material_initial_tab_renders():\n    \"\"\"Verify Material tabs show initial tab content.\"\"\"\n    response = client.get(\"/layouts?style=material\")\n    assert response.status_code == 200\n    # Assert initial content and Material tab classes\n    assert \"Initial Tab Content\" in response.text\n    assert 'data-toggle=\"tab\"' in response.text\n</code></pre> <p>This coverage ensures that tab layouts work correctly across frameworks.</p>"},{"location":"validation_guide/#pydantic-v2-deprecation-resolution","title":"Pydantic v2 Deprecation Resolution","text":"<p>As of this release, all Pydantic v2 deprecation warnings have been resolved:</p> <p>\u2705 Resolved Deprecations: - <code>min_items</code>/<code>max_items</code> \u2192 <code>min_length</code>/<code>max_length</code> in all FormField calls - Extra kwargs on <code>Field()</code> \u2192 properly use <code>json_schema_extra</code> - Starlette <code>TemplateResponse</code> signature updated to new parameter order</p> <p>Result: Deprecation warnings reduced from 23 \u2192 8 (removed 15 Pydantic deprecations). The remaining 8 warnings are intentional migration guides (<code>form_layouts</code> deprecation notice) and informational (JSON schema hints).</p> <p>Run validation tests: <pre><code>python -m pytest tests/test_validation_consolidation.py -v\npython -m pytest tests/test_layout_demo_smoke.py -v\n</code></pre></p>"},{"location":"validation_guide/#summary","title":"Summary","text":"<p>The unified validation engine provides:</p> <ol> <li>Canonical ValidationResponse for all validation flows</li> <li>Single code path via <code>validation.py</code> with re-exports from <code>live_validation.py</code></li> <li>Flexible rule composition via <code>FieldValidator</code> and <code>FormValidator</code></li> <li>HTMX integration via <code>LiveValidator</code> with configurable behavior</li> <li>Cross-field validation for dependent fields and complex rules</li> <li>Convenience validators for common patterns (email, password strength)</li> <li>Full async support for FastAPI and async frameworks</li> <li>Pydantic v2 compatibility with zero deprecation warnings in critical paths</li> </ol> <p>For questions or examples, see: - <code>tests/test_validation_consolidation.py</code> \u2014 Consolidated validation tests (10 tests) - <code>tests/test_layout_demo_smoke.py</code> \u2014 Layout/tab rendering verification - <code>examples/fastapi_example.py</code> \u2014 Real-world FastAPI integration</p>"}]}