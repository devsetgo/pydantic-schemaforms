{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pydantic SchemaForms","text":"<p>Support Python Versions</p> <p> </p> <p>CI/CD Pipeline: </p> <p>SonarCloud:</p> <p> </p> <p>Note: This project should be considered in beta as it is actively under development and may have breaking changes.</p>"},{"location":"#overview","title":"Overview","text":"<p>pydantic-schemaforms is a modern Python library that generates dynamic HTML forms from Pydantic 2.x+ models.</p> <p>It is designed for server-rendered apps: you define a model (and optional UI hints) and get back ready-to-embed HTML with validation and framework styling.</p> <p>Key Features: - \ud83d\ude80 Zero-Configuration Forms: Generate complete HTML forms directly from Pydantic models - \ud83c\udfa8 Multi-Framework Support: Bootstrap, Material Design, Tailwind CSS, and custom frameworks - \u2705 Built-in Validation: Client-side HTML5 + server-side Pydantic validation - \ud83d\udd27 JSON-Schema-form style UI hints: Uses a familiar <code>ui_element</code>, <code>ui_autofocus</code>, <code>ui_options</code> vocabulary - \ud83d\udcf1 Responsive &amp; Accessible: Mobile-first design with full ARIA support - \ud83c\udf10 Framework Ready: First-class Flask and FastAPI helpers, plus plain HTML for other stacks</p> <p>Important: <code>submit_url</code> is required when rendering forms. The library does not choose a default submit target.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Docs site: https://devsetgo.github.io/pydantic-schemaforms/</li> <li>Live Demo: https://pydantic-schemaforms.devsetgo.com</li> <li>Source: https://github.com/devsetgo/pydantic-schemaforms</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.14+</li> <li>Pydantic 2.7+ (included in library)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#install","title":"Install","text":"<pre><code>pip install pydantic-schemaforms\n</code></pre>"},{"location":"#fastapi-async-asgi","title":"FastAPI (async / ASGI)","text":"<p>This is the recommended \u201cdrop-in HTML\u201d pattern for FastAPI: define a <code>FormModel</code> and call <code>render_form_html()</code>.</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom pydantic import ValidationError\n\nfrom pydantic_schemaforms.enhanced_renderer import render_form_html\nfrom pydantic_schemaforms.schema_form import Field, FormModel\n\n\nclass MinimalLoginForm(FormModel):\n    username: str = Field(\n        title=\"Username\",\n        ui_autofocus=True,\n        ui_placeholder=\"demo_user\",\n    )\n    password: str = Field(\n        title=\"Password\",\n        ui_element=\"password\",\n    )\n    remember_me: bool = Field(\n        default=False,\n        title=\"Remember me\",\n        ui_element=\"checkbox\",\n    )\n\n\napp = FastAPI()\n\n\n@app.api_route(\"/login\", methods=[\"GET\", \"POST\"], response_class=HTMLResponse)\nasync def login(request: Request, style: str = \"bootstrap\"):\n    form_data = {}\n    errors = {}\n\n    if request.method == \"POST\":\n        submitted = dict(await request.form())\n        form_data = submitted\n        try:\n            MinimalLoginForm(**submitted)\n        except ValidationError as e:\n            errors = {err[\"loc\"][0]: err[\"msg\"] for err in e.errors() if err.get(\"loc\")}\n    else:\n        # optional demo data\n        form_data = {\"username\": \"demo_user\", \"remember_me\": True}\n\n    form_html = render_form_html(\n        MinimalLoginForm,\n        framework=style,\n        form_data=form_data,\n        errors=errors,\n        submit_url=\"/login\",\n    )\n\n    return f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\\\"en\\\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\\\"utf-8\\\"&gt;\n  &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\"&gt;\n  &lt;title&gt;Login&lt;/title&gt;\n  &lt;link href=\\\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\"&gt;\n&lt;/head&gt;\n&lt;body class=\\\"container my-5\\\"&gt;\n  &lt;h1 class=\\\"mb-4\\\"&gt;Login&lt;/h1&gt;\n  {form_html}\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre> <p>Run it:</p> <pre><code>pip install \"pydantic-schemaforms[fastapi]\" uvicorn\nuvicorn main:app --reload\n</code></pre>"},{"location":"#fastapi-simple-registration-page","title":"FastAPI: simple registration page","text":"<p>This mirrors the in-repo example apps: your host page loads Bootstrap, and <code>render_form_html()</code> returns form markup (plus any inline helper scripts), ready to embed.</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom pydantic import ValidationError\n\nfrom pydantic_schemaforms.enhanced_renderer import render_form_html\nfrom pydantic_schemaforms.schema_form import FormModel, Field\n\n\nclass UserRegistrationForm(FormModel):\n    username: str = Field(title=\"Username\", min_length=3)\n    email: str = Field(title=\"Email\", ui_element=\"email\")\n    password: str = Field(title=\"Password\", ui_element=\"password\", min_length=8)\n\n\napp = FastAPI()\n\n\n@app.api_route(\"/register\", methods=[\"GET\", \"POST\"], response_class=HTMLResponse)\nasync def register(request: Request):\n    form_data = {}\n    errors = {}\n\n    if request.method == \"POST\":\n        submitted = dict(await request.form())\n        form_data = submitted\n        try:\n            UserRegistrationForm(**submitted)\n        except ValidationError as e:\n            errors = {err[\"loc\"][0]: err[\"msg\"] for err in e.errors() if err.get(\"loc\")}\n\n    form_html = render_form_html(\n        UserRegistrationForm,\n        framework=\"bootstrap\",\n        form_data=form_data,\n        errors=errors,\n        submit_url=\"/register\",\n    )\n\n    return f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\\\"en\\\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\\\"utf-8\\\"&gt;\n  &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\"&gt;\n  &lt;title&gt;Register&lt;/title&gt;\n  &lt;link href=\\\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\"&gt;\n&lt;/head&gt;\n&lt;body class=\\\"container my-5\\\"&gt;\n  &lt;h1 class=\\\"mb-4\\\"&gt;Register&lt;/h1&gt;\n  {form_html |safe}\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"#flask-sync-wsgi","title":"Flask (sync / WSGI)","text":"<p>In synchronous apps (Flask), the simplest pattern is the same: define a <code>FormModel</code> and call <code>render_form_html()</code>.</p> <pre><code>from flask import Flask, request\nfrom pydantic import ValidationError\n\nfrom pydantic_schemaforms.enhanced_renderer import render_form_html\nfrom pydantic_schemaforms.schema_form import Field, FormModel\n\n\nclass MinimalLoginForm(FormModel):\n    username: str = Field(title=\"Username\", ui_autofocus=True)\n    password: str = Field(title=\"Password\", ui_element=\"password\")\n    remember_me: bool = Field(default=False, title=\"Remember me\", ui_element=\"checkbox\")\n\n\napp = Flask(__name__)\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    form_data = {}\n    errors = {}\n\n    if request.method == \"POST\":\n        submitted = request.form.to_dict()\n        form_data = submitted\n        try:\n            MinimalLoginForm(**submitted)\n        except ValidationError as e:\n            errors = {err[\"loc\"][0]: err[\"msg\"] for err in e.errors() if err.get(\"loc\")}\n\n    form_html = render_form_html(\n        MinimalLoginForm,\n        framework=\"bootstrap\",\n        form_data=form_data,\n        errors=errors,\n        submit_url=\"/login\",\n    )\n\n    return f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\\\"en\\\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\\\"utf-8\\\"&gt;\n  &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\"&gt;\n  &lt;title&gt;Login&lt;/title&gt;\n  &lt;link href=\\\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\"&gt;\n&lt;/head&gt;\n&lt;body class=\\\"container my-5\\\"&gt;\n  &lt;h1 class=\\\"mb-4\\\"&gt;Login&lt;/h1&gt;\n  {form_html|safe}\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"#flask-simple-registration-page","title":"Flask: simple registration page","text":"<pre><code>from flask import Flask, request\nfrom pydantic import ValidationError\n\nfrom pydantic_schemaforms.enhanced_renderer import render_form_html\nfrom pydantic_schemaforms.schema_form import FormModel, Field\n\n\nclass UserRegistrationForm(FormModel):\n    username: str = Field(title=\"Username\", min_length=3)\n    email: str = Field(title=\"Email\", ui_element=\"email\")\n    password: str = Field(title=\"Password\", ui_element=\"password\", min_length=8)\n\n\napp = Flask(__name__)\n\n\n@app.route(\"/register\", methods=[\"GET\", \"POST\"])\ndef register():\n    form_data = {}\n    errors = {}\n\n    if request.method == \"POST\":\n        submitted = request.form.to_dict()\n        form_data = submitted\n        try:\n            UserRegistrationForm(**submitted)\n        except ValidationError as e:\n            errors = {err[\"loc\"][0]: err[\"msg\"] for err in e.errors() if err.get(\"loc\")}\n\n    form_html = render_form_html(\n        UserRegistrationForm,\n        framework=\"bootstrap\",\n        form_data=form_data,\n        errors=errors,\n        submit_url=\"/register\",\n    )\n\n    return f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\\\"en\\\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\\\"utf-8\\\"&gt;\n  &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\"&gt;\n  &lt;title&gt;Register&lt;/title&gt;\n  &lt;link href=\\\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\"&gt;\n&lt;/head&gt;\n&lt;body class=\\\"container my-5\\\"&gt;\n  &lt;h1 class=\\\"mb-4\\\"&gt;Register&lt;/h1&gt;\n  {form_html|safe}\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"#ui-vocabulary-compatibility","title":"UI vocabulary compatibility","text":"<p>The library supports a JSON-Schema-form style vocabulary (UI hints like input types and options), but you can also stay \u201cpure Pydantic\u201d and let the defaults drive everything.</p> <p>See the docs site for the current, supported UI hint patterns.</p>"},{"location":"#framework-support","title":"Framework Support","text":""},{"location":"#bootstrap-5-recommended","title":"Bootstrap 5 (Recommended)","text":"<p><pre><code>UserForm.render_form(framework=\"bootstrap\", submit_url=\"/submit\")\n</code></pre> - Complete Bootstrap integration - Form validation states and styling - Responsive grid system - Custom form controls</p> <p>Note: Bootstrap markup/classes are always generated, but Bootstrap CSS/JS are only included if your host template provides them or you opt into <code>self_contained=True</code> / <code>include_framework_assets=True</code>.</p>"},{"location":"#self-contained-bootstrap-no-host-template-assets","title":"Self-contained Bootstrap (no host template assets)","text":"<p>If you want a single HTML string that includes Bootstrap CSS/JS inline (no CDN, no global layout requirements), use the <code>self_contained=True</code> convenience flag:</p> <pre><code>from pydantic_schemaforms.enhanced_renderer import render_form_html\n\nform_html = render_form_html(\n    UserRegistrationForm,\n    framework=style,\n    form_data=form_data,\n    debug=debug,\n    self_contained=True,\n    submit_url=\"/register\",\n)\n</code></pre> <p>You can also call the <code>FormModel</code> convenience if you prefer:</p> <pre><code>form_html = UserRegistrationForm.render_form(\n    data=form_data,\n    framework=style,\n    debug=debug,\n    self_contained=True,\n    submit_url=\"/register\",\n)\n</code></pre>"},{"location":"#material-design","title":"Material Design","text":"<p><pre><code>UserForm.render_form(framework=\"material\", submit_url=\"/submit\")\n</code></pre> - Materialize CSS framework - Floating labels and animations - Material icons integration</p>"},{"location":"#plain-html","title":"Plain HTML","text":"<p><pre><code>UserForm.render_form(framework=\"none\", submit_url=\"/submit\")\n</code></pre> - Clean HTML5 forms - No framework dependencies - Easy to style with custom CSS - FastAPI example support: append <code>?style=none</code> (for example: <code>/login?style=none&amp;demo=true</code>)</p>"},{"location":"#renderer-architecture","title":"Renderer Architecture","text":"<ul> <li>EnhancedFormRenderer is the canonical renderer. It walks the Pydantic <code>FormModel</code>, feeds the shared <code>LayoutEngine</code>, and delegates chrome/assets to a <code>RendererTheme</code>.</li> <li>ModernFormRenderer now piggybacks on Enhanced by generating a throwaway <code>FormModel</code> from legacy <code>FormDefinition</code>/<code>FormField</code> helpers. It exists so existing builder/integration code keeps working while still benefiting from the shared pipeline. (The old <code>Py314Renderer</code> alias has been removed; import <code>ModernFormRenderer</code> directly when you need the builder DSL.)</li> </ul> <p>Because everything flows through Enhanced, fixes to layout, validation, or framework themes immediately apply to every renderer (Bootstrap, Material, embedded/self-contained, etc.). Choose the renderer based on the API surface you prefer (Pydantic models for <code>FormModel</code> or the builder DSL for <code>ModernFormRenderer</code>); the generated HTML is orchestrated by the same core engine either way.</p>"},{"location":"#advanced-examples","title":"Advanced Examples","text":""},{"location":"#file-upload-form","title":"File Upload Form","text":"<pre><code>class FileUploadForm(FormModel):\n    title: str = Field(..., description=\"Upload title\")\n    files: str = Field(\n        ...,\n        description=\"Select files\",\n        ui_element=\"file\",\n        ui_options={\"accept\": \".pdf,.docx\", \"multiple\": True}\n    )\n    description: str = Field(\n        ...,\n        description=\"File description\",\n        ui_element=\"textarea\",\n        ui_options={\"rows\": 3}\n    )\n</code></pre>"},{"location":"#event-creation-form","title":"Event Creation Form","text":"<pre><code>class EventForm(FormModel):\n    event_name: str = Field(..., description=\"Event name\", ui_autofocus=True)\n    event_datetime: str = Field(\n        ...,\n        description=\"Event date and time\",\n        ui_element=\"datetime-local\"\n    )\n    max_attendees: int = Field(\n        ...,\n        ge=1,\n        le=1000,\n        description=\"Maximum attendees\",\n        ui_element=\"number\"\n    )\n    is_public: bool = Field(\n        True,\n        description=\"Make event public\",\n        ui_element=\"checkbox\"\n    )\n    theme_color: str = Field(\n        \"#3498db\",\n        description=\"Event color\",\n        ui_element=\"color\"\n    )\n</code></pre>"},{"location":"#form-validation","title":"Form Validation","text":"<pre><code>from pydantic import ValidationError\n\n@app.route(\"/submit\", methods=[\"POST\"])\ndef handle_submit():\n    try:\n        # Validate form data using your Pydantic model\n        user_data = UserForm(**request.form)\n\n        # Process valid data\n        return f\"Welcome {user_data.username}!\"\n\n    except ValidationError as e:\n        # Handle validation errors\n        errors = e.errors()\n        return f\"Validation failed: {errors}\", 400\n</code></pre>"},{"location":"#flask-integration","title":"Flask Integration","text":"<p>Complete Flask application example:</p> <pre><code>from flask import Flask, request, render_template_string\nfrom pydantic import ValidationError\nfrom pydantic_schemaforms.schema_form import FormModel, Field\n\napp = Flask(__name__)\n\nclass UserRegistrationForm(FormModel):\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=20,\n        description=\"Choose a unique username\",\n        ui_autofocus=True\n    )\n    email: str = Field(\n        ...,\n        description=\"Your email address\",\n        ui_element=\"email\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        description=\"Choose a secure password\",\n        ui_element=\"password\"\n    )\n    age: int = Field(\n        ...,\n        ge=13,\n        le=120,\n        description=\"Your age\",\n        ui_element=\"number\"\n    )\n    newsletter: bool = Field(\n        False,\n        description=\"Subscribe to our newsletter\",\n        ui_element=\"checkbox\"\n    )\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef registration():\n    if request.method == \"POST\":\n        try:\n            # Validate form data\n            user = UserRegistrationForm(**request.form)\n            return f\"Registration successful for {user.username}!\"\n        except ValidationError as e:\n            errors = e.errors()\n            # Re-render form with errors\n            form_html = UserRegistrationForm.render_form(\n                framework=\"bootstrap\",\n                submit_url=\"/\",\n                errors=errors\n            )\n            return render_template_string(BASE_TEMPLATE, form_html=form_html)\n\n    # Render empty form\n    form_html = UserRegistrationForm.render_form(framework=\"bootstrap\", submit_url=\"/\")\n    return render_template_string(BASE_TEMPLATE, form_html=form_html)\n\nBASE_TEMPLATE = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;User Registration&lt;/title&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container my-5\"&gt;\n        &lt;h1&gt;User Registration&lt;/h1&gt;\n        {{ form_html | safe }}\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"#render-timing","title":"Render Timing","text":"<p>The library automatically measures form rendering time with multiple display options:</p>"},{"location":"#display-timing-below-submit-button","title":"Display Timing Below Submit Button","text":"<p>Add a small timing display to your form:</p> <pre><code>html = render_form_html(MyForm, show_timing=True, submit_url=\"/submit\")\n</code></pre> <p>This shows: Rendered in 0.0045s</p>"},{"location":"#display-in-debug-panel","title":"Display in Debug Panel","text":"<p>Include comprehensive debugging information:</p> <pre><code>html = render_form_html(MyForm, debug=True, submit_url=\"/submit\")\n</code></pre> <p>Shows timing in the debug panel header: Debug panel (development only) \u2014 0.0045s render</p>"},{"location":"#automatic-info-level-logging","title":"Automatic INFO-Level Logging","text":"<p>Timing is always logged at INFO level:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.INFO)\n\nhtml = render_form_html(MyForm, submit_url=\"/submit\")\n# Logs: INFO pydantic_schemaforms.enhanced_renderer: Form rendered in 0.0045s\n</code></pre> <p>Use Cases: - Development: Use <code>show_timing=True</code> to see performance quickly - Debugging: Use <code>debug=True</code> to see form structure and timing - Production: Timing is logged automatically at INFO level for monitoring</p> <p>See Render Timing Docs for complete details.</p>"},{"location":"#application-logging","title":"Application Logging","text":"<p>The library provides optional DEBUG-level logging that respects your application's logging configuration:</p>"},{"location":"#automatic-timing-logs","title":"Automatic Timing Logs","text":"<p>Timing is always logged at INFO level (for production monitoring):</p> <pre><code>import logging\nfrom pydantic_schemaforms import render_form_html\n\nlogging.basicConfig(level=logging.INFO)\nhtml = render_form_html(MyForm, submit_url=\"/submit\")\n# Timing is logged automatically\n</code></pre>"},{"location":"#optional-debug-logs","title":"Optional Debug Logs","text":"<p>Enable DEBUG logging to see detailed rendering steps:</p> <pre><code>import logging\nfrom pydantic_schemaforms import render_form_html\n\n# Option 1: Application-level DEBUG\nlogging.basicConfig(level=logging.DEBUG)\nhtml = render_form_html(MyForm, submit_url=\"/submit\")\n# \u2705 Timing + debug logs appear\n\n# Option 2: Per-render control\nhtml = render_form_html(MyForm, enable_logging=True, submit_url=\"/submit\")\n# \u2705 Debug logs appear for this render only\n</code></pre>"},{"location":"#selective-logger-configuration","title":"Selective Logger Configuration","text":"<p>Enable library debugging without affecting your app's logging:</p> <pre><code>import logging\n\n# Application at INFO level\nlogging.basicConfig(level=logging.INFO)\n\n# Library DEBUG logs\nlibrary_logger = logging.getLogger('pydantic_schemaforms')\nlibrary_logger.setLevel(logging.DEBUG)\n\nhtml = render_form_html(MyForm, submit_url=\"/submit\")\n# \u2705 Library debug logs visible\n# \u2705 App remains at INFO level\n</code></pre> <p>Best Practice: Use Approach 1 (application-level configuration) in most cases. The library respects your app's logging setup.</p> <p>See Application Logging Docs for complete details and integration examples.</p>"},{"location":"#examples-in-this-repository","title":"Examples in This Repository","text":"<p>The main runnable demo in this repo is the FastAPI example:</p> <ul> <li>Run: <code>make ex-run</code></li> <li>Visit: http://localhost:8000</li> <li>Self-contained demo: http://localhost:8000/self-contained</li> </ul> <p>See <code>examples/fastapi_example.py</code> and <code>examples/shared_models.py</code> for the complete implementation.</p> <p>Logging and timing examples: - Timing Options Example - Display options for render timing - Timing Demo - Complete timing feature demonstration - Logging Example - Logging configuration patterns - Logging Control Example - Fine-grained logging control</p>"},{"location":"#supported-input-types","title":"Supported Input Types","text":"<p>Text Inputs: - <code>text</code> (default), <code>email</code>, <code>password</code>, <code>search</code> - <code>tel</code>, <code>url</code> - <code>textarea</code></p> <p>Numeric Inputs: - <code>number</code>, <code>range</code></p> <p>Date/Time Inputs: - <code>date</code>, <code>time</code>, <code>datetime-local</code> - <code>week</code>, <code>month</code></p> <p>Selection Inputs: - <code>checkbox</code>, <code>radio</code>, <code>select</code></p> <p>Specialized Inputs: - <code>file</code>, <code>color</code>, <code>hidden</code></p> <p>Input Options: All HTML5 input attributes are supported through <code>ui_options</code> or Field parameters.</p>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#formmodel","title":"FormModel","text":"<p>Extend your Pydantic models with <code>FormModel</code> to add form rendering capabilities:</p> <pre><code>from pydantic_schemaforms.schema_form import FormModel, Field\n\nclass MyForm(FormModel):\n    field_name: str = Field(..., ui_element=\"email\")\n\n# Render Bootstrap markup (expects host page to load Bootstrap)\nhtml = MyForm.render_form(framework=\"bootstrap\", submit_url=\"/submit\")\n\n# Render fully self-contained Bootstrap HTML (inlines vendored Bootstrap CSS/JS)\nhtml = MyForm.render_form(framework=\"bootstrap\", submit_url=\"/submit\", self_contained=True)\n</code></pre>"},{"location":"#field-function","title":"Field Function","text":"<p>Enhanced Field function with UI element support:</p> <pre><code>Field(\n    default=...,           # Pydantic default value\n    description=\"Label\",   # Field label\n    ui_element=\"email\",    # Input type\n    ui_autofocus=True,     # Auto-focus field\n    ui_options={...},      # Additional options\n    # All standard Pydantic Field options...\n)\n</code></pre>"},{"location":"#framework-options","title":"Framework Options","text":"<ul> <li><code>\"bootstrap\"</code> - Bootstrap 5 styling (recommended)</li> <li><code>\"material\"</code> - Material Design (Materialize CSS)</li> <li><code>\"none\"</code> - Plain HTML5 forms</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please check out the Contributing Guide for details.</p> <p>Development Setup: <pre><code>git clone https://github.com/devsetgo/pydantic-schemaforms.git\ncd pydantic-schemaforms\npip install -e .\n</code></pre></p> <p>Run Tests: <pre><code>python -m pytest tests/\n</code></pre></p>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: pydantic-schemaforms Docs</li> <li>Repository: GitHub</li> <li>PyPI: pydantic-schemaforms</li> <li>Issues: Bug Reports &amp; Feature Requests</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details: https://github.com/devsetgo/pydantic-schemaforms/blob/main/LICENSE</p>"},{"location":"about/","title":"About","text":"<p><code>pydantic-schemaforms</code> is a Python library for generating server-rendered HTML forms from Pydantic models.</p> <p>It focuses on:</p> <ul> <li>A simple model \u2192 schema \u2192 HTML pipeline</li> <li>First-class sync (WSGI) and async (ASGI) integration helpers</li> <li>Offline-by-default asset delivery (vendored/inlined assets), with explicit opt-in for CDNs</li> </ul> <p>If you\u2019re new, start here:</p> <ul> <li>Quick Start</li> <li>Configuration</li> <li>Inputs (UI Elements)</li> <li>Layouts</li> <li>Assets</li> </ul> <p>Project links:</p> <ul> <li>Docs: https://devsetgo.github.io/pydantic-schemaforms/</li> <li>GitHub: https://github.com/devsetgo/pydantic-schemaforms</li> <li>PyPI: https://pypi.org/project/pydantic-schemaforms/</li> </ul>"},{"location":"about/#about-me","title":"About Me","text":"<p>I am a software engineering manager with an eclectic background in various industries (finance, manufacturing, and metrology). I am passionate about software development and love to learn new things.</p> <ul> <li>DevSetGo.com</li> <li>Github</li> <li>X.com</li> </ul>"},{"location":"assets/","title":"Assets &amp; <code>asset_mode</code>","text":"<p><code>pydantic-schemaforms</code> is offline-by-default: by default, rendered HTML ships all required JS/CSS from this library (vendored assets are embedded/packaged).</p> <p>This page documents the standard knobs used across entry points to control asset injection.</p>"},{"location":"assets/#terminology","title":"Terminology","text":"<ul> <li>Vendored assets: Third-party JS/CSS copied into this repo under <code>pydantic_schemaforms/assets/vendor/**</code>.</li> <li>Pinned: Versions are recorded in <code>pydantic_schemaforms/assets/vendor/vendor_manifest.json</code> along with <code>sha256</code> checksums and source URLs.</li> <li><code>asset_mode</code>: How a renderer should include assets.</li> </ul>"},{"location":"assets/#asset_mode-values","title":"<code>asset_mode</code> values","text":"<p>Most APIs accept <code>asset_mode</code> with these values:</p> <ul> <li><code>\"vendored\"</code> (default)</li> <li>No external network required.</li> <li> <p>Assets are inlined (e.g., <code>&lt;script&gt;\u2026&lt;/script&gt;</code> / <code>&lt;style&gt;\u2026&lt;/style&gt;</code>) from the packaged vendor files.</p> </li> <li> <p><code>\"cdn\"</code> (explicit opt-in)</p> </li> <li>Emits <code>&lt;script src=\"\u2026\"&gt;</code> / <code>&lt;link href=\"\u2026\"&gt;</code> tags pointing at a CDN.</li> <li> <p>URLs are pinned to the versions in the vendored manifest.</p> </li> <li> <p><code>\"none\"</code></p> </li> <li>Emits no assets.</li> <li>Useful when your host app provides its own asset pipeline.</li> </ul>"},{"location":"assets/#entry-points","title":"Entry points","text":""},{"location":"assets/#legacy-wrapper-render_form_html","title":"Legacy wrapper: <code>render_form_html()</code>","text":"<p>File: <code>pydantic_schemaforms/render_form.py</code></p> <ul> <li><code>asset_mode=\"vendored\" | \"cdn\" | \"none\"</code></li> <li><code>include_framework_assets</code>: whether to include framework CSS/JS (Bootstrap/Materialize) in the returned HTML.</li> <li>HTMX is included by default (vendored inline) because this wrapper historically assumed HTMX.</li> <li>IMask is available but not injected unless requested.</li> </ul> <p>Example:</p> <pre><code>from pydantic_schemaforms.render_form import render_form_html\n\nhtml = render_form_html(\n    MyForm,\n    framework=\"bootstrap\",\n    asset_mode=\"vendored\",\n    include_framework_assets=True,  # inline Bootstrap CSS/JS for self-contained HTML\n    include_imask=True,  # enable when you use masked inputs\n)\n</code></pre> <p>If you already provide Bootstrap/Materialize in your host app (a global layout, bundler, etc.), keep <code>include_framework_assets=False</code> and use <code>asset_mode=\"none\"</code> or <code>\"vendored\"</code> depending on whether you still want the helper to inject HTMX.</p>"},{"location":"assets/#enhanced-convenience-helper-enhanced_rendererrender_form_html","title":"Enhanced convenience helper: <code>enhanced_renderer.render_form_html()</code>","text":"<p>File: <code>pydantic_schemaforms/enhanced_renderer.py</code></p> <ul> <li><code>include_framework_assets</code>: include framework CSS/JS in the returned HTML (default: <code>False</code>).</li> <li><code>asset_mode</code>: controls how those assets are emitted.</li> <li><code>self_contained=True</code>: convenience flag equivalent to <code>include_framework_assets=True</code> and <code>asset_mode=\"vendored\"</code>.</li> </ul> <p>Example (simple \u201cjust give me a fully styled Bootstrap form\u201d):</p> <pre><code>from pydantic_schemaforms.enhanced_renderer import render_form_html\n\nhtml = render_form_html(\n  MyForm,\n  framework=\"bootstrap\",\n  self_contained=True,\n)\n</code></pre> <p>Unlike the legacy wrapper, this helper does not append HTMX/IMask tags; it\u2019s a thin convenience wrapper around <code>EnhancedFormRenderer</code>.</p>"},{"location":"assets/#enhanced-renderer-enhancedformrenderer","title":"Enhanced renderer: <code>EnhancedFormRenderer</code>","text":"<p>File: <code>pydantic_schemaforms/enhanced_renderer.py</code></p> <ul> <li><code>include_framework_assets</code>: whether the renderer should include framework CSS/JS.</li> <li><code>asset_mode</code>: controls whether those assets are vendored inline or pinned CDN URLs.</li> </ul> <p>Example:</p> <pre><code>from pydantic_schemaforms.enhanced_renderer import EnhancedFormRenderer\n\nrenderer = EnhancedFormRenderer(\n    framework=\"bootstrap\",\n    include_framework_assets=True,\n    asset_mode=\"vendored\",\n)\nhtml = renderer.render_form_from_model(MyForm)\n</code></pre>"},{"location":"assets/#modernbuilder-path-formbuilder-render_form_page","title":"Modern/builder path: <code>FormBuilder</code> + <code>render_form_page()</code>","text":"<p>File: <code>pydantic_schemaforms/integration/builder.py</code></p> <ul> <li><code>FormBuilder(..., include_framework_assets=..., asset_mode=...)</code> controls how the builder\u2019s form HTML is rendered.</li> <li><code>render_form_page(..., include_framework_assets=..., asset_mode=...)</code> controls the full-page wrapper\u2019s CSS/JS emission.</li> </ul> <p>Example:</p> <pre><code>from pydantic_schemaforms.integration.builder import FormBuilder, render_form_page\n\nbuilder = FormBuilder(\n    framework=\"bootstrap\",\n    include_framework_assets=True,\n    asset_mode=\"vendored\",\n).text_input(\"ssn\", \"SSN\")\n\npage = render_form_page(\n    builder,\n    title=\"Signup\",\n    include_framework_assets=True,\n    asset_mode=\"vendored\",\n)\n</code></pre>"},{"location":"assets/#whats-currently-vendored","title":"What\u2019s currently vendored","text":"<ul> <li>HTMX</li> <li>IMask</li> <li>Bootstrap (CSS + bundle JS)</li> <li>Materialize (CSS + JS)</li> </ul> <p>See <code>pydantic_schemaforms/assets/vendor/vendor_manifest.json</code> for exact versions and file paths.</p>"},{"location":"assets/#updating-vendored-assets","title":"Updating vendored assets","text":"<p>Vendored updates are scripted and checksum-verified.</p> <ul> <li>Verify vendored checksums:</li> <li> <p><code>make vendor-verify</code></p> </li> <li> <p>Update assets:</p> </li> <li><code>make vendor-update-htmx HTMX_VERSION=\u2026</code></li> <li><code>make vendor-update-imask IMASK_VERSION=\u2026</code> (or omit to use npm latest)</li> <li><code>make vendor-update-bootstrap BOOTSTRAP_VERSION=\u2026</code></li> <li><code>make vendor-update-materialize MATERIALIZE_VERSION=\u2026</code></li> </ul> <p>After updating, run <code>make vendor-verify</code> and the test suite.</p>"},{"location":"assets/#security-note","title":"Security note","text":"<p><code>asset_mode=\"cdn\"</code> is intentionally available, but it re-introduces an external dependency at runtime. For production systems with strict supply-chain or offline requirements, prefer <code>asset_mode=\"vendored\"</code>.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>This library is driven almost entirely by render-time options (which framework/theme to target, whether to inline assets, what layout to use) plus field-level UI metadata stored in your model\u2019s JSON Schema.</p>"},{"location":"configuration/#rendering-entry-points","title":"Rendering entry points","text":"<p><code>submit_url</code> is required for render calls. This library does not default form submit targets.</p> <p>You can render forms in a few different ways. Pick one that matches your project style:</p>"},{"location":"configuration/#1-model-first-recommended","title":"1) Model-first (recommended)","text":"<p>Use <code>FormModel</code> + <code>render_form_html()</code>.</p> <pre><code>from pydantic_schemaforms import Field, FormModel\nfrom pydantic_schemaforms.enhanced_renderer import render_form_html\n\n\nclass RegistrationForm(FormModel):\n    name: str = Field(..., ui_placeholder=\"Jane\")\n    email: str = Field(..., ui_element=\"email\")\n\n\nform_html = render_form_html(\n    RegistrationForm,\n    submit_url=\"/register\",\n    framework=\"bootstrap\",\n    layout=\"vertical\",\n)\n</code></pre> <p>If you prefer a method on the model, use <code>RegistrationForm.render_form(...)</code>.</p>"},{"location":"configuration/#2-builder-handlers-legacy-integration","title":"2) Builder + handlers (legacy integration)","text":"<p>Docs and examples may still reference the builder pattern:</p> <ul> <li>Build with <code>create_form_from_model()</code></li> <li>Validate + render with <code>handle_form()</code> / <code>handle_form_async()</code></li> </ul> <p>This remains supported for backwards compatibility, but the underlying HTML rendering flows through the same enhanced renderer pipeline.</p>"},{"location":"configuration/#framework-and-assets","title":"Framework and assets","text":"<p>There are two separate but related concepts:</p> <ul> <li>Framework selection: <code>framework=\"bootstrap\" | \"material\" | \"none\"</code></li> <li>Asset delivery: whether the form HTML includes the framework CSS/JS</li> </ul>"},{"location":"configuration/#include_framework_assets","title":"<code>include_framework_assets</code>","text":"<ul> <li><code>False</code> (default): the returned HTML assumes your page already loads Bootstrap/Material.</li> <li><code>True</code>: the renderer emits framework CSS/JS tags.</li> </ul>"},{"location":"configuration/#asset_mode","title":"<code>asset_mode</code>","text":"<p>Controls how the framework assets are provided when <code>include_framework_assets=True</code>:</p> <ul> <li><code>\"vendored\"</code>: inline the vendored CSS/JS into the output (offline-friendly).</li> <li><code>\"cdn\"</code>: link to a CDN.</li> <li><code>\"none\"</code>: emit no framework tags.</li> </ul>"},{"location":"configuration/#self_contained","title":"<code>self_contained</code>","text":"<p>For convenience, <code>self_contained=True</code> forces a fully-embedded result:</p> <ul> <li><code>include_framework_assets=True</code></li> <li><code>asset_mode=\"vendored\"</code></li> </ul> <pre><code>html = render_form_html(\n    RegistrationForm,\n    submit_url=\"/register\",\n    self_contained=True,\n)\n</code></pre> <p>See also: docs/assets.md</p>"},{"location":"configuration/#layout-selection","title":"Layout selection","text":"<p>At the top level, pass <code>layout=</code> to the renderer:</p> <ul> <li><code>\"vertical\"</code> (default)</li> <li><code>\"tabbed\"</code></li> <li><code>\"side-by-side\"</code></li> </ul> <pre><code>html = render_form_html(RegistrationForm, layout=\"tabbed\", submit_url=\"/register\")\n</code></pre> <p>For advanced composition (tabs/accordion/grid wrappers and schema-defined layout fields), see docs/layouts.md.</p>"},{"location":"configuration/#field-ui-metadata","title":"Field UI metadata","text":"<p>UI metadata is stored in <code>json_schema_extra</code> with keys like <code>ui_element</code>, <code>ui_placeholder</code>, etc. The library provides a convenience wrapper <code>pydantic_schemaforms.Field()</code> that populates these keys.</p> <p>Common UI keys:</p> <ul> <li><code>ui_element</code>: widget type (see docs/inputs.md)</li> <li><code>ui_placeholder</code></li> <li><code>ui_help_text</code></li> <li><code>ui_options</code>: widget-specific options (e.g. selection choices)</li> <li><code>ui_class</code>, <code>ui_style</code></li> <li><code>ui_disabled</code>, <code>ui_readonly</code>, <code>ui_hidden</code>, <code>ui_autofocus</code></li> <li><code>ui_order</code>: field ordering</li> </ul> <p>Example:</p> <pre><code>class ProfileForm(FormModel):\n    bio: str = Field(\n        \"\",\n        title=\"Bio\",\n        description=\"A short bio shown publicly\",\n        ui_element=\"textarea\",\n        ui_placeholder=\"Tell us about yourself\u2026\",\n        ui_options={\"rows\": 6},\n        ui_order=10,\n    )\n</code></pre>"},{"location":"configuration/#escaping-and-templates-safe","title":"Escaping and templates (<code>|safe</code>)","text":"<ul> <li>If you return the HTML string directly from a framework response (e.g. FastAPI <code>HTMLResponse</code>), no extra escaping happens.</li> <li>If you embed the HTML into a Jinja template, you must mark it safe:</li> </ul> <pre><code>{{ form_html | safe }}\n</code></pre> <p>Otherwise Jinja will escape the markup and you\u2019ll see literal <code>&lt;div&gt;</code> tags in the browser.</p>"},{"location":"configuration/#error-rendering-behavior","title":"Error rendering behavior","text":"<p>When you pass <code>errors=</code> to <code>render_form_html()</code> / <code>render_form_html_async()</code>, the renderer now includes a built-in top-level summary block inside <code>form_html</code>.</p> <ul> <li>Field paths are humanized for users (example: <code>pets[7].name</code> \u2192 <code>Pet #8 \u2014 Name</code>).</li> <li>The same behavior works for Bootstrap and Material output.</li> <li>No template-side error loop is required for standard usage.</li> </ul> <p>This means most templates only need:</p> <pre><code>{{ form_html | safe }}\n</code></pre>"},{"location":"configuration/#layout-support-behavior","title":"Layout support behavior","text":"<p>The enhanced renderer injects a small internal style block to keep nested/layout-heavy forms (<code>layout</code>, <code>model_list</code>, tabbed/side-by-side structures) width-safe across host templates.</p> <ul> <li>This reduces the need for route-specific template CSS hacks.</li> <li>If your app provides strict custom CSS, you can still override these classes in your host stylesheet.</li> </ul>"},{"location":"contribute/","title":"Contributing","text":"<p>Please feel free to contribute to this project. Adding common functions is the intent and if you have one to add or improve an existing it is greatly appreciated.</p>"},{"location":"contribute/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Add or improve a function</li> <li>Add or improve documentation</li> <li>Add or improve tests</li> <li>Report or fix a bug</li> </ul>"},{"location":"inputs/","title":"Inputs (UI Elements)","text":"<p>This page documents the supported <code>ui_element</code> values and their expected options.</p> <p>Where you set these:</p> <ul> <li>Preferred: <code>pydantic_schemaforms.Field(..., ui_element=\"...\")</code></li> <li>Or directly via <code>json_schema_extra={\"ui_element\": \"...\"}</code></li> </ul> <pre><code>from pydantic_schemaforms import Field, FormModel\n\n\nclass Example(FormModel):\n    email: str = Field(..., ui_element=\"email\")\n</code></pre>"},{"location":"inputs/#supported-ui_element-values","title":"Supported <code>ui_element</code> values","text":"<p>These map to concrete input components in <code>pydantic_schemaforms.inputs.*</code>.</p>"},{"location":"inputs/#text","title":"Text","text":"<ul> <li><code>text</code> (default)</li> <li><code>password</code></li> <li><code>email</code></li> <li><code>search</code></li> <li><code>textarea</code></li> <li><code>url</code></li> <li><code>tel</code></li> </ul> <p>Notes:</p> <ul> <li>Long string fields may auto-infer to <code>textarea</code>.</li> <li><code>password</code> preserves the value if you supply one (use with care).</li> </ul>"},{"location":"inputs/#numbers","title":"Numbers","text":"<ul> <li><code>number</code></li> <li><code>range</code></li> </ul>"},{"location":"inputs/#selection","title":"Selection","text":"<ul> <li><code>select</code></li> <li><code>multiselect</code></li> <li><code>checkbox</code></li> <li><code>radio</code></li> <li><code>toggle</code> (aliases: <code>toggle_switch</code>, <code>checkbox_toggle</code>)</li> <li><code>combobox</code></li> </ul> <p>Options for selection widgets:</p> <ul> <li>Provide choices via <code>ui_options={\"options\": [...]}</code> or <code>ui_options={\"choices\": [...]}</code>.</li> <li>Or use JSON Schema enums (e.g. <code>Literal[...]</code> / <code>Enum</code>) and the renderer will infer options.</li> </ul> <p>Example:</p> <pre><code>class Preferences(FormModel):\n    favorite_color: str = Field(\n        ...,\n        ui_element=\"select\",\n        ui_options={\n            \"options\": [\n                {\"value\": \"red\", \"label\": \"Red\"},\n                {\"value\": \"blue\", \"label\": \"Blue\"},\n            ]\n        },\n    )\n</code></pre>"},{"location":"inputs/#datetime","title":"Date/time","text":"<ul> <li><code>date</code></li> <li><code>time</code></li> <li><code>datetime</code> (alias: <code>datetime-local</code>)</li> <li><code>month</code></li> <li><code>week</code></li> </ul>"},{"location":"inputs/#specialized","title":"Specialized","text":"<ul> <li><code>file</code></li> <li><code>color</code></li> <li><code>hidden</code></li> <li><code>ssn</code> (alias: <code>social_security_number</code>)</li> <li><code>phone</code> (alias: <code>phone_number</code>)</li> <li><code>credit_card</code> (aliases: <code>card</code>, <code>cc_number</code>)</li> <li><code>currency</code> (alias: <code>money</code>)</li> </ul> <p>These specialized elements are opt-in and will not override normal <code>text</code> fields. Use them explicitly when you want built-in formatting/pattern behavior.</p>"},{"location":"inputs/#pseudo-elements","title":"Pseudo elements","text":"<p>These are handled specially by the renderer (not standard inputs):</p> <ul> <li><code>layout</code>: layout-only schema fields (see docs/layouts.md)</li> <li><code>model_list</code>: repeatable nested model items</li> </ul>"},{"location":"inputs/#unknown-elements","title":"Unknown elements","text":"<p>If you set <code>ui_element</code> to an unsupported value, the renderer falls back to a basic text input.</p> <p>If you need a custom widget:</p> <ul> <li>Implement a <code>BaseInput</code> subclass</li> <li>Register it at runtime via <code>pydantic_schemaforms.inputs.registry.register_input_class()</code></li> </ul> <p>(Then you can use your custom <code>ui_element</code> key in schemas.)</p>"},{"location":"layouts/","title":"Layouts","text":"<p>There are two layers of layout support:</p> <p>1) Top-level layout modes (<code>layout=</code> when you render the form) 2) Composable layout primitives (horizontal/grid/tabs/etc) for advanced composition</p>"},{"location":"layouts/#1-top-level-layout-modes","title":"1) Top-level layout modes","text":"<p>Pass <code>layout=</code> to <code>render_form_html()</code> / <code>FormModel.render_form()</code>.</p> <p>Supported values:</p> <ul> <li><code>vertical</code> (default)</li> <li><code>tabbed</code>: groups fields into tabs automatically</li> <li><code>side-by-side</code>: renders fields in two-column rows</li> </ul> <pre><code>from pydantic_schemaforms.enhanced_renderer import render_form_html\n\nhtml = render_form_html(MyFormModel, layout=\"side-by-side\")\n</code></pre>"},{"location":"layouts/#2-layout-primitives-advanced","title":"2) Layout primitives (advanced)","text":"<p>The module <code>pydantic_schemaforms.rendering.layout_engine</code> contains reusable wrappers:</p> <ul> <li><code>HorizontalLayout</code></li> <li><code>VerticalLayout</code></li> <li><code>GridLayout</code></li> <li><code>ResponsiveGridLayout</code></li> <li><code>TabLayout</code></li> <li><code>AccordionLayout</code></li> <li><code>CardLayout</code></li> <li><code>ModalLayout</code></li> </ul> <p>A convenience factory is provided:</p> <ul> <li><code>LayoutComposer</code> (aliases: <code>Layout</code>, <code>LayoutFactory</code>)</li> </ul> <p>Example:</p> <pre><code>from pydantic_schemaforms.rendering.layout_engine import Layout\n\nlayout = Layout.grid(\n    \"&lt;div&gt;Left&lt;/div&gt;\",\n    \"&lt;div&gt;Right&lt;/div&gt;\",\n    columns=\"1fr 2fr\",\n    gap=\"1rem\",\n)\n\nhtml = layout.render(framework=\"bootstrap\", renderer=my_renderer, data={}, errors={})\n</code></pre>"},{"location":"layouts/#schema-defined-layout-fields","title":"Schema-defined layout fields","text":"<p>A schema field with <code>ui_element=\"layout\"</code> is treated as a layout field.</p> <p>At render time, the renderer will:</p> <ul> <li>Call a custom layout renderer if you configured one (<code>layout_handler</code> / <code>layout_renderer</code>)</li> <li>Or, if the field value is a <code>BaseLayout</code> instance, call its <code>.render()</code></li> </ul> <p>This is intentionally an advanced feature (useful for complex nested forms and custom layout engines).</p>"},{"location":"layouts/#registering-custom-layout-renderers","title":"Registering custom layout renderers","text":"<p>You can register a named layout renderer:</p> <pre><code>from pydantic_schemaforms.rendering.layout_engine import LayoutEngine\n\n\ndef my_layout_renderer(field_name, field_schema, value, ui_info, context, engine):\n    return \"&lt;div&gt;Custom layout output&lt;/div&gt;\"\n\n\nLayoutEngine.register_layout_renderer(\"my_layout\", my_layout_renderer)\n</code></pre> <p>Then set <code>ui_options</code> (or schema <code>ui</code>) to reference it:</p> <ul> <li><code>layout_handler=\"my_layout\"</code> or <code>layout_renderer=\"my_layout\"</code></li> </ul>"},{"location":"layouts/#notes","title":"Notes","text":"<ul> <li><code>tabbed</code> grouping is heuristic-based (field-name keywords). If you need deterministic tabbing, use explicit layout fields or custom renderers.</li> <li>Layout fields can include nested form markup via <code>EnhancedFormRenderer.render_form_fields_only()</code>.</li> </ul>"},{"location":"library-boundary-risk-analysis/","title":"Library Boundary &amp; Security Risk Analysis","text":""},{"location":"library-boundary-risk-analysis/#context","title":"Context","text":"<p>Your stated rule is:</p> <ul> <li>The library renders and validates forms.</li> <li>The application owns endpoint routing and submission destinations.</li> <li>The library must not make app-specific assumptions.</li> </ul> <p>This is aligned with secure framework design:</p> <ol> <li>App layer decides trust boundaries (routes, auth, tenancy, CSRF policy).</li> <li>Library layer stays generic (rendering, schema parsing, model validation).</li> </ol>"},{"location":"library-boundary-risk-analysis/#issue-1-app-specific-special-case-in-core","title":"Issue 1: App-specific special case in core","text":"<p>Location: <code>pydantic_schemaforms/rendering/layout_engine.py</code> (<code>field_name == \"comprehensive_tabs\"</code> branch)</p>"},{"location":"library-boundary-risk-analysis/#why-this-is-risky","title":"Why this is risky","text":"<p>The core library now contains behavior tied to one example form field name (<code>comprehensive_tabs</code>).</p> <p>That causes:</p> <ul> <li>Coupling to demo/app internals: core behavior depends on one specific field naming convention.</li> <li>Hidden precedence rules: data can be reshaped unexpectedly when that key appears.</li> <li>Non-obvious behavior for consumers: users with similarly named fields may get unintended transformations.</li> <li>Maintenance drift: adding more app-specific exceptions scales badly and becomes fragile.</li> </ul>"},{"location":"library-boundary-risk-analysis/#security-angle","title":"Security angle","text":"<p>This is more of an architectural boundary risk than a direct exploit by itself.</p> <p>However, implicit reshaping in core can become security-relevant when:</p> <ul> <li>validation and authorization logic in apps assumes a different input shape,</li> <li>field-level allowlists/denylists are bypassed by transformation order,</li> <li>audit logs capture transformed payloads that no longer match incoming data.</li> </ul>"},{"location":"library-boundary-risk-analysis/#recommended-direction","title":"Recommended direction","text":"<p>Remove hardcoded field-name logic from core and replace with one of:</p> <ul> <li>Schema-driven generic resolution (preferred): detect layout fields by metadata (<code>ui_element/layout</code>) and resolve nested values generically.</li> <li>Pluggable hook: app can register a resolver for custom field mapping.</li> <li>No implicit mapping: require input to already match model shape; apps perform mapping explicitly.</li> </ul>"},{"location":"library-boundary-risk-analysis/#decision-tradeoff","title":"Decision tradeoff","text":"<ul> <li>Generic schema-driven core gives best developer experience with minimal policy risk.</li> <li>Explicit app mapping gives strongest predictability and least surprise.</li> </ul>"},{"location":"library-boundary-risk-analysis/#issue-2-preserving-unknown-submitted-keys-in-validated-output","title":"Issue 2: Preserving unknown submitted keys in validated output","text":"<p>Location: <code>pydantic_schemaforms/validation.py</code> around unknown-key preservation</p>"},{"location":"library-boundary-risk-analysis/#why-this-is-risky_1","title":"Why this is risky","text":"<p>The current behavior appends keys from raw input if they are not part of validated model output.</p> <p>This can leak unvalidated transport fields into the final <code>result.data</code> payload.</p>"},{"location":"library-boundary-risk-analysis/#concrete-failure-modes","title":"Concrete failure modes","text":"<ol> <li>Data contamination</li> <li>Output looks validated but includes non-model keys.</li> <li> <p>Downstream code may trust all keys in the payload.</p> </li> <li> <p>Privilege/flag smuggling</p> </li> <li>Attackers can include fields like <code>is_admin</code>, <code>role</code>, <code>tenant_id</code>, <code>approved</code>, etc.</li> <li> <p>Even if model ignores them, preservation reintroduces them into the final payload.</p> </li> <li> <p>Mass assignment risk in follow-on layers</p> </li> <li> <p>If downstream persistence uses broad dict writes, unknown keys may be persisted or acted upon.</p> </li> <li> <p>Audit ambiguity</p> </li> <li>\u201cValidated data\u201d is no longer strictly validated model data.</li> </ol>"},{"location":"library-boundary-risk-analysis/#security-severity","title":"Security severity","text":"<p>This is a real security concern in multi-layer systems where consumers assume validated output is safe.</p> <p>Severity depends on what downstream does, but the default should be conservative.</p>"},{"location":"library-boundary-risk-analysis/#recommended-direction_1","title":"Recommended direction","text":"<p>Default policy should be:</p> <ul> <li>Return only model-shaped validated data.</li> <li>Do not merge unknown keys into validated output.</li> </ul> <p>If compatibility is needed, use explicit opt-in modes:</p> <ul> <li><code>strict</code> (default): model-only output.</li> <li><code>include_raw_extra</code> (opt-in): include unknowns under a separate namespace, e.g. <code>_extra</code>.</li> </ul> <p>This preserves debuggability without contaminating trusted data.</p>"},{"location":"library-boundary-risk-analysis/#related-principle-submit-destination-ownership","title":"Related Principle: Submit destination ownership","text":"<p>You noted: sending <code>?style={style}</code> in <code>submit_url</code> is app-owned and acceptable.</p> <p>Agreed. The key security principle:</p> <ul> <li>Library may render whatever <code>submit_url</code> the app passes.</li> <li>Library must not infer or auto-construct submission routes beyond safe defaults.</li> <li>Library defaults should be inert (<code>/submit</code>), explicit, and overridable.</li> </ul> <p>This keeps route ownership with the application and avoids accidental data exfiltration paths.</p>"},{"location":"library-boundary-risk-analysis/#suggested-policy-decisions","title":"Suggested policy decisions","text":"<p>Choose one policy set and apply consistently:</p>"},{"location":"library-boundary-risk-analysis/#option-a-recommended","title":"Option A (recommended)","text":"<ul> <li>Remove app-specific hardcoded mappings from core.</li> <li>Keep only generic schema-driven layout behavior.</li> <li>Return only validated model-shaped output.</li> <li>If extras are needed, expose separately (e.g. <code>_extra</code>) via opt-in.</li> </ul>"},{"location":"library-boundary-risk-analysis/#option-b-compatibility-first","title":"Option B (compatibility-first)","text":"<ul> <li>Keep current behavior behind feature flags.</li> <li>Default to secure behavior for new users.</li> <li>Offer migration period for legacy apps.</li> </ul>"},{"location":"library-boundary-risk-analysis/#migration-plan-low-risk","title":"Migration plan (low risk)","text":"<ol> <li>Add a validation output policy setting with default <code>strict</code>.</li> <li>Deprecate unknown-key merge behavior with warning.</li> <li>Remove <code>comprehensive_tabs</code> special case and replace with generic resolver.</li> <li>Add tests covering:</li> <li>no app-specific field-name assumptions,</li> <li>unknown key handling under strict/compat modes,</li> <li>nested layout payload correctness.</li> </ol>"},{"location":"library-boundary-risk-analysis/#bottom-line","title":"Bottom line","text":"<p>Both flagged items are valid concerns.</p> <ul> <li>The hardcoded <code>comprehensive_tabs</code> branch violates library/app separation.</li> <li>Unknown key preservation can blur trust boundaries and create security risk.</li> </ul> <p>If your goal is a secure, framework-grade library contract, Option A is the safer long-term decision.</p>"},{"location":"logging/","title":"Logging","text":"<p>The pydantic-schemaforms library uses Python's standard logging module to provide visibility into form rendering operations. By default, the library logs at DEBUG level, so logs won't appear in typical production setups.</p>"},{"location":"logging/#overview","title":"Overview","text":"<p>Logging in pydantic-schemaforms is designed to:</p> <ul> <li>\u2705 Not interfere with your application's logging</li> <li>\u2705 Provide detailed debug information when needed</li> <li>\u2705 Use standard Python logging practices</li> <li>\u2705 Always log timing information (at INFO level, not DEBUG)</li> </ul>"},{"location":"logging/#logging-levels","title":"Logging Levels","text":""},{"location":"logging/#library-logs-debug-level","title":"Library Logs (DEBUG level)","text":"<p>The library uses DEBUG level for detailed information:</p> <pre><code>import logging\n\n# Configure to see library DEBUG logs\nlogging.basicConfig(level=logging.DEBUG)\n\nfrom pydantic_schemaforms import render_form_html\n\nhtml = render_form_html(MyForm)\n# Now you'll see DEBUG logs from the library\n</code></pre> <p>Examples of DEBUG logs: - Schema parsing steps - Field rendering decisions - Asset inclusion checks - Layout calculations</p>"},{"location":"logging/#timing-logs-info-level","title":"Timing Logs (INFO level)","text":"<p>Render timing is logged at INFO level, so it appears even in production:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.INFO)\n\nhtml = render_form_html(MyForm)\n# Output: INFO pydantic_schemaforms.enhanced_renderer: Form rendered in 0.0045s\n</code></pre> <p>This is intentional - timing metrics are valuable for production monitoring while keeping other debug logs suppressed.</p>"},{"location":"logging/#configuration-approaches","title":"Configuration Approaches","text":""},{"location":"logging/#approach-1-application-level-control-recommended","title":"Approach 1: Application-Level Control (Recommended)","text":"<p>Configure your application's logging level. The library respects it:</p> <pre><code>import logging\n\n# Production: INFO level\nlogging.basicConfig(level=logging.INFO)\n# \u2705 Timing logs appear\n# \u274c Library DEBUG logs suppressed\n\n# Development: DEBUG level\nlogging.basicConfig(level=logging.DEBUG)\n# \u2705 Timing logs appear\n# \u2705 Library DEBUG logs appear\n\n# Silent: WARNING level\nlogging.basicConfig(level=logging.WARNING)\n# \u274c Timing logs suppressed\n# \u274c Library DEBUG logs suppressed\n</code></pre> <p>Pros: - Standard Python logging approach - Simple and predictable - Works with all logging handlers</p> <p>Cons: - Can't selectively enable library logs without enabling all DEBUG logs</p>"},{"location":"logging/#approach-2-library-specific-control","title":"Approach 2: Library-Specific Control","text":"<p>Enable/disable logging per render call:</p> <pre><code>from pydantic_schemaforms import render_form_html\n\n# Enable library DEBUG logs for this render\nhtml = render_form_html(MyForm, enable_logging=True)\n\n# Disable library DEBUG logs even if DEBUG level is set\nhtml = render_form_html(MyForm, enable_logging=False)\n</code></pre> <p>Pros: - Fine-grained control per call - Can debug specific forms</p> <p>Cons: - <code>enable_logging</code> only controls DEBUG level - <code>enable_logging</code> doesn't affect timing logs (INFO level)</p> <p>Note: <code>enable_logging</code> is for DEBUG logs. Timing (INFO level) is always logged unless you configure logging levels.</p>"},{"location":"logging/#approach-3-selective-logger-configuration","title":"Approach 3: Selective Logger Configuration","text":"<p>Enable DEBUG logging only for the library:</p> <pre><code>import logging\n\n# Application logs at INFO level\nlogging.basicConfig(level=logging.INFO)\n\n# Library logs at DEBUG level\nlibrary_logger = logging.getLogger('pydantic_schemaforms')\nlibrary_logger.setLevel(logging.DEBUG)\n\nfrom pydantic_schemaforms import render_form_html\n\nhtml = render_form_html(MyForm)\n# \u2705 Timing logs appear (INFO)\n# \u2705 Library DEBUG logs appear\n# \u2705 Other DEBUG logs from your app are suppressed\n</code></pre> <p>Pros: - Selective logging without affecting app - Can debug library without app noise</p> <p>Cons: - More complex setup - Requires understanding logger hierarchy</p>"},{"location":"logging/#practical-scenarios","title":"Practical Scenarios","text":""},{"location":"logging/#production-server","title":"Production Server","text":"<pre><code># At app startup\nimport logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Forms render normally\nhtml = render_form_html(MyForm)\n# \u2705 Timing appears in logs for monitoring\n# \u274c Debug logs suppressed\n</code></pre>"},{"location":"logging/#local-development","title":"Local Development","text":"<pre><code># At app startup\nimport logging\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(levelname)s - %(name)s - %(message)s'\n)\n\n# See all details\nhtml = render_form_html(MyForm)\n# \u2705 Timing logs appear\n# \u2705 Detailed library DEBUG logs appear\n</code></pre>"},{"location":"logging/#development-want-app-logs-only","title":"Development (Want App Logs Only)","text":"<pre><code>import logging\n\n# App at DEBUG level, library at WARNING level\nlogging.basicConfig(level=logging.DEBUG)\nlogging.getLogger('pydantic_schemaforms').setLevel(logging.WARNING)\n\nhtml = render_form_html(MyForm)\n# \u2705 Your app's DEBUG logs appear\n# \u274c Library logs suppressed\n</code></pre>"},{"location":"logging/#debugging-a-specific-form","title":"Debugging a Specific Form","text":"<pre><code>import logging\n\n# Global INFO level\nlogging.basicConfig(level=logging.INFO)\n\n# Debug this specific form\nhtml = render_form_html(MyForm, enable_logging=True)\n\n# Render other forms normally (no debug logs)\nhtml2 = render_form_html(OtherForm)\n</code></pre>"},{"location":"logging/#fastapi-integration","title":"FastAPI Integration","text":""},{"location":"logging/#example-1-production-setup","title":"Example 1: Production Setup","text":"<pre><code>from fastapi import FastAPI\nimport logging\n\napp = FastAPI()\n\n# Configure logging once at startup\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s'\n)\n\nfrom pydantic_schemaforms import render_form_html, FormModel, Field\n\nclass LoginForm(FormModel):\n    username: str = Field(...)\n    password: str = Field(..., ui_element=\"password\")\n\n@app.get(\"/login\")\ndef login_page():\n    html = render_form_html(LoginForm, framework=\"bootstrap\")\n    # \u2705 Timing automatically logged\n    # \u274c No debug spam\n    return f\"&lt;html&gt;&lt;body&gt;{html}&lt;/body&gt;&lt;/html&gt;\"\n</code></pre>"},{"location":"logging/#example-2-development-with-debug-toggle","title":"Example 2: Development with Debug Toggle","text":"<pre><code>from fastapi import FastAPI, Query\nimport logging\n\napp = FastAPI()\n\n# Configure at DEBUG for development\nlogging.basicConfig(level=logging.DEBUG)\n\nfrom pydantic_schemaforms import render_form_html\n\n@app.get(\"/login\")\ndef login_page(debug: bool = False):\n    # Control logging per request\n    html = render_form_html(\n        LoginForm,\n        enable_logging=debug,\n        debug=debug,  # Also show debug panel\n        framework=\"bootstrap\"\n    )\n    return f\"&lt;html&gt;&lt;body&gt;{html}&lt;/body&gt;&lt;/html&gt;\"\n\n# Visit /login for normal form\n# Visit /login?debug=true for debug logs + panel\n</code></pre>"},{"location":"logging/#example-3-custom-log-handler","title":"Example 3: Custom Log Handler","text":"<pre><code>import logging\nfrom pythonjsonlogger import jsonlogger\n\n# Use JSON logging\nlogHandler = logging.StreamHandler()\nformatter = jsonlogger.JsonFormatter()\nlogHandler.setFormatter(formatter)\n\nlogger = logging.getLogger()\nlogger.addHandler(logHandler)\nlogger.setLevel(logging.INFO)\n\nfrom fastapi import FastAPI\nfrom pydantic_schemaforms import render_form_html\n\napp = FastAPI()\n\n@app.get(\"/login\")\ndef login_page():\n    html = render_form_html(LoginForm, framework=\"bootstrap\")\n    # \u2705 Timing logged as JSON for structured logging\n    return f\"&lt;html&gt;&lt;body&gt;{html}&lt;/body&gt;&lt;/html&gt;\"\n</code></pre>"},{"location":"logging/#flask-integration","title":"Flask Integration","text":""},{"location":"logging/#basic-setup","title":"Basic Setup","text":"<pre><code>from flask import Flask\nimport logging\n\napp = Flask(__name__)\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(message)s'\n)\n\nfrom pydantic_schemaforms import render_form_html\n\n@app.route(\"/login\")\ndef login():\n    html = render_form_html(LoginForm, framework=\"bootstrap\")\n    # \u2705 Timing automatically logged\n    return f\"&lt;html&gt;&lt;body&gt;{html}&lt;/body&gt;&lt;/html&gt;\"\n</code></pre>"},{"location":"logging/#conditional-logging","title":"Conditional Logging","text":"<pre><code>import logging\nfrom flask import Flask\n\napp = Flask(__name__)\n\n# Configure based on environment\nlog_level = logging.DEBUG if app.debug else logging.INFO\nlogging.basicConfig(level=log_level)\n\n# Can also use Flask's logger\napp.logger.setLevel(log_level)\n\nfrom pydantic_schemaforms import render_form_html\n\n@app.route(\"/login\")\ndef login():\n    html = render_form_html(LoginForm, framework=\"bootstrap\")\n    # \u2705 Respects Flask's log level\n    return f\"&lt;html&gt;&lt;body&gt;{html}&lt;/body&gt;&lt;/html&gt;\"\n</code></pre>"},{"location":"logging/#logger-names","title":"Logger Names","text":"<p>The library uses these logger names for organization:</p> <pre><code>import logging\n\n# Main renderer logger - timing and general info\nrenderer_logger = logging.getLogger('pydantic_schemaforms.enhanced_renderer')\n\n# Root library logger - all components\nroot_logger = logging.getLogger('pydantic_schemaforms')\n\n# Configure root to affect all components\nroot_logger.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"logging/#reference","title":"Reference","text":""},{"location":"logging/#logging-control-parameters","title":"Logging Control Parameters","text":"Parameter Type Default Effect <code>enable_logging</code> <code>bool</code> <code>False</code> Enable DEBUG-level library logs for this render <p>Important: <code>enable_logging</code> only affects DEBUG level logs. Timing (INFO level) is always logged and controlled by your application's logging configuration.</p>"},{"location":"logging/#log-levels-in-use","title":"Log Levels in Use","text":"Level Who Controls Use Case INFO Application logging config Timing metrics, important events DEBUG <code>enable_logging</code> param + app config Detailed rendering steps, diagnostics WARNING Application logging config Important warnings, issues"},{"location":"logging/#best-practices","title":"Best Practices","text":""},{"location":"logging/#do","title":"\u2705 DO","text":"<ul> <li>Use application-level logging configuration (Approach 1)</li> <li>Configure INFO level for production (to see timing)</li> <li>Enable DEBUG level during development (to see all details)</li> <li>Use standard Python logging handlers and formatters</li> <li>Log to structured formats (JSON) in production</li> </ul>"},{"location":"logging/#dont","title":"\u274c DON'T","text":"<ul> <li>Rely on <code>enable_logging</code> for production debugging</li> <li>Configure library logging differently from your app</li> <li>Expect DEBUG logs without DEBUG level configured</li> <li>Forget that timing is INFO level (appears in production)</li> </ul>"},{"location":"logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"logging/#logs-not-appearing","title":"Logs Not Appearing","text":"<p>Problem: Library logs don't appear even with <code>enable_logging=True</code>.</p> <p>Solution: Check logging level:</p> <pre><code>import logging\n\n# \u274c WRONG - WARNING suppresses DEBUG\nlogging.basicConfig(level=logging.WARNING)\nhtml = render_form_html(MyForm, enable_logging=True)\n\n# \u2705 CORRECT - INFO or DEBUG allows logs\nlogging.basicConfig(level=logging.DEBUG)\nhtml = render_form_html(MyForm, enable_logging=True)\n</code></pre>"},{"location":"logging/#too-many-logs","title":"Too Many Logs","text":"<p>Problem: Library logs are overwhelming your app logs.</p> <p>Solution: Configure library logger separately:</p> <pre><code>import logging\n\n# App at DEBUG\nlogging.basicConfig(level=logging.DEBUG)\n\n# Library at WARNING (suppress DEBUG logs)\nlogging.getLogger('pydantic_schemaforms').setLevel(logging.WARNING)\n</code></pre>"},{"location":"logging/#cant-find-timing-in-logs","title":"Can't Find Timing in Logs","text":"<p>Problem: Timing logs aren't appearing.</p> <p>Solution: Timing logs at INFO level:</p> <pre><code>import logging\n\n# \u274c WRONG - WARNING suppresses INFO\nlogging.basicConfig(level=logging.WARNING)\n\n# \u2705 CORRECT - INFO or DEBUG shows timing\nlogging.basicConfig(level=logging.INFO)\n</code></pre>"},{"location":"logging/#json-logging-not-working","title":"JSON Logging Not Working","text":"<p>Problem: Logs don't serialize to JSON properly.</p> <p>Solution: Ensure JSON formatter handles all log attributes:</p> <pre><code>from pythonjsonlogger import jsonlogger\nimport logging\n\nhandler = logging.StreamHandler()\nformatter = jsonlogger.JsonFormatter(\n    '%(asctime)s %(name)s %(levelname)s %(message)s'\n)\nhandler.setFormatter(formatter)\n\nlogger = logging.getLogger()\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n</code></pre>"},{"location":"plugin_hooks/","title":"Plugin Hooks for Inputs and Layouts","text":"<p>This project now exposes lightweight extension points so third-party packages (or your own app code) can add new inputs or layout renderers without patching core modules.</p>"},{"location":"plugin_hooks/#registering-custom-inputs","title":"Registering Custom Inputs","text":"<p>Use <code>pydantic_schemaforms.inputs.registry.register_input_class</code> to bind a <code>BaseInput</code> subclass to one or more <code>ui_element</code> aliases. The registry augments the built-in discovery of subclasses so you can register at import time or inside your framework startup.</p> <pre><code>from pydantic_schemaforms.inputs.base import BaseInput\nfrom pydantic_schemaforms.inputs.registry import register_input_class\n\nclass ColorSwatchInput(BaseInput):\n    ui_element = \"color_swatch\"\n\n    # implement render_input / render_label, etc.\n\nregister_input_class(ColorSwatchInput)\n</code></pre> <ul> <li>Aliases: pass <code>aliases=(\"color\", \"swatch\")</code> if you want multiple trigger names.</li> <li>Bulk registration: use <code>register_inputs([Cls1, Cls2, ...])</code>.</li> <li>Reset (tests/hot reload): <code>reset_input_registry()</code> clears custom entries and cache.</li> </ul> <p>Once registered, any field with <code>input_type=\"color_swatch\"</code> (or alias) will resolve to your component.</p>"},{"location":"plugin_hooks/#registering-custom-layout-renderers","title":"Registering Custom Layout Renderers","text":"<p><code>LayoutEngine</code> can now dispatch layout fields to custom renderers before falling back to built-in demos. Provide a callable and reference it from a field via <code>layout_handler</code> (or <code>layout_renderer</code>) in <code>json_schema_extra</code> / <code>FormField</code> kwargs.</p> <pre><code>from pydantic_schemaforms.rendering.layout_engine import LayoutEngine\n\n# signature: (field_name, field_schema, value, ui_info, context, engine) -&gt; str\ndef render_steps(field_name, field_schema, value, ui_info, context, engine):\n    # value may be your own layout descriptor; use engine._renderer if needed\n    steps = value or []\n    items = \"\".join(f\"&lt;li&gt;{step}&lt;/li&gt;\" for step in steps)\n    return f\"&lt;ol class='steps'&gt;{items}&lt;/ol&gt;\"\n\nLayoutEngine.register_layout_renderer(\"steps\", render_steps)\n</code></pre> <p>Attach the handler in your form field:</p> <pre><code>class WizardForm(FormModel):\n    steps: list[str] = FormField(\n        [\"Account\", \"Billing\", \"Review\"],\n        input_type=\"layout\",\n        layout_handler=\"steps\",\n        title=\"Wizard Steps\",\n    )\n</code></pre> <ul> <li>Names are arbitrary strings; collisions overwrite the previous handler.</li> <li>Call <code>LayoutEngine.reset_layout_renderers()</code> in tests to clear state.</li> <li>Handlers receive the active <code>LayoutEngine</code> instance and the original renderer via <code>engine._renderer</code> if you need to reuse field rendering helpers.</li> </ul>"},{"location":"plugin_hooks/#packaging-tips","title":"Packaging Tips","text":"<ul> <li>For libraries: register your inputs/layouts in your package <code>__init__</code> or an explicit <code>setup()</code> function that users call during startup.</li> <li>For app code: register once at process start (e.g., FastAPI lifespan, Django AppConfig.ready). Avoid per-request registration.</li> <li>Keep renderers pure and side-effect free; they should return HTML strings and not mutate shared state.</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This page shows two common ways to integrate pydantic-schemaforms into an app:</p> <ul> <li>Model-first rendering (<code>FormModel</code> + <code>render_form_html()</code>)</li> <li>Builder + handlers (legacy):<ul> <li>Build a <code>FormBuilder</code> (often via <code>create_form_from_model()</code>)</li> <li>Use exactly one handler per runtime:<ul> <li>Sync: <code>handle_form()</code></li> <li>Async: <code>handle_form_async()</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"quickstart/#option-a-model-first-rendering-recommended","title":"Option A: Model-first rendering (recommended)","text":"<pre><code>from pydantic_schemaforms import Field, FormModel, render_form_html\n\n\nclass User(FormModel):\n    name: str = Field(...)\n    email: str = Field(..., ui_element=\"email\")\n\n\nhtml = render_form_html(User, submit_url=\"/user\")\n</code></pre>"},{"location":"quickstart/#async-fastapi-asgi","title":"Async (FastAPI / ASGI)","text":"<pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\n\nfrom pydantic_schemaforms import Field, FormModel, render_form_html_async\n\n\nclass User(FormModel):\n    name: str = Field(...)\n    email: str = Field(..., ui_element=\"email\")\n\n\napp = FastAPI()\n\n\n@app.api_route(\"/user\", methods=[\"GET\", \"POST\"], response_class=HTMLResponse)\nasync def user_form(request: Request):\n    form_data = {}\n    errors = {}\n\n    if request.method == \"POST\":\n        submitted = dict(await request.form())\n        form_data = submitted\n        try:\n            User(**submitted)\n        except Exception as exc:\n            errors = {\"form\": str(exc)}\n\n    form_html = await render_form_html_async(\n        User,\n        form_data=form_data,\n        errors=errors,\n        submit_url=\"/user\",\n    )\n\n    return f\"\"\"\n    &lt;!doctype html&gt;\n    &lt;html&gt;\n    &lt;body&gt;\n      &lt;h1&gt;User&lt;/h1&gt;\n      {form_html}\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre> <p>You can also call <code>await User.render_form_async(...)</code> directly if you prefer a model method. <pre><code>If your host page already loads Bootstrap/Material, keep defaults. If you want a fully self-contained HTML chunk, pass `self_contained=True`.\n\nSee: `docs/configuration.md` and `docs/assets.md`.\n\n## 1) Build a form from a Pydantic model\n\n```python\nfrom pydantic import BaseModel, EmailStr\n\nfrom pydantic_schemaforms import create_form_from_model\n\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n\n\nbuilder = create_form_from_model(User, framework=\"bootstrap\")\n</code></pre></p>"},{"location":"quickstart/#2-async-integration-fastapi-asgi","title":"2) Async integration (FastAPI / ASGI)","text":"<pre><code>from fastapi import FastAPI, Request\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form_async\n\napp = FastAPI()\n\n\n@app.api_route(\"/user\", methods=[\"GET\", \"POST\"])\nasync def user_form(request: Request):\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        form = await request.form()\n        result = await handle_form_async(builder, submitted_data=dict(form))\n        if result.get(\"success\"):\n            return {\"ok\": True, \"data\": result[\"data\"]}\n        return result[\"form_html\"]\n\n    result = await handle_form_async(builder)\n    return result[\"form_html\"]\n</code></pre>"},{"location":"quickstart/#3-sync-integration-flask-wsgi","title":"3) Sync integration (Flask / WSGI)","text":"<pre><code>from flask import Flask, request\n\nfrom pydantic_schemaforms import create_form_from_model, handle_form\n\napp = Flask(__name__)\n\n\n@app.route(\"/user\", methods=[\"GET\", \"POST\"])\ndef user_form():\n    builder = create_form_from_model(User, framework=\"bootstrap\")\n\n    if request.method == \"POST\":\n        result = handle_form(builder, submitted_data=request.form.to_dict())\n        if result.get(\"success\"):\n            return f\"Saved: {result['data']}\"\n        return result[\"form_html\"]\n\n    return handle_form(builder)[\"form_html\"]\n</code></pre>"},{"location":"quickstart/#notes","title":"Notes","text":"<ul> <li><code>handle_form*()</code> returns either <code>{form_html}</code> (initial render) or <code>{success: bool, ...}</code> (submission).</li> <li>Asset delivery (<code>asset_mode</code>) and full-page wrappers are documented in <code>docs/assets.md</code>.</li> </ul>"},{"location":"release-notes/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p>"},{"location":"release-notes/#unreleased-since-untagged-bfb3bb98aa31ca386d88","title":"Unreleased (since untagged-bfb3bb98aa31ca386d88)","text":""},{"location":"release-notes/#breaking-changes","title":"Breaking Changes","text":"<ul> <li><code>submit_url</code> is now explicit across public form render APIs and no longer defaults silently.</li> <li>Calls that omit <code>submit_url</code> now raise a clear error, enforcing app-owned routing boundaries.</li> </ul>"},{"location":"release-notes/#added","title":"Added","text":"<ul> <li>Async-first rendering flow improvements and examples.</li> <li>FastAPI form/style GET+POST matrix testing to validate route and style combinations.</li> <li>Expanded coverage suites for renderer/input modules and validation pathways.</li> </ul>"},{"location":"release-notes/#changed","title":"Changed","text":"<ul> <li>Layout rendering internals refactored for maintainability and reduced cognitive complexity.</li> <li>Reliability and maintainability improvements to satisfy SonarCloud findings.</li> <li>Improved nested/collapsible form behavior when multiple forms are rendered on a page.</li> <li>Better timing/logging support in examples and diagnostics.</li> </ul>"},{"location":"release-notes/#fixed","title":"Fixed","text":"<ul> <li>Removed implicit default submit target behavior (<code>/submit</code>) and aligned all call sites/tests.</li> <li>Fixed FastAPI showcase POST re-render path by passing explicit submit target in error flows.</li> <li>Fixed datetime/month/week conversion edge cases (<code>datetime</code> vs <code>date</code> branch ordering).</li> <li>Fixed model-list and nested rendering edge behavior across schema and runtime paths.</li> </ul>"},{"location":"release-notes/#dependencies","title":"Dependencies","text":"<ul> <li><code>fastapi[all]</code>: <code>0.121.2</code> \u2192 <code>0.128.4</code></li> <li><code>ruff</code>: <code>0.14.14</code> \u2192 <code>0.15.0</code></li> <li><code>tqdm</code>: <code>4.67.1</code> \u2192 <code>4.67.3</code></li> <li><code>pytest-html</code>: <code>4.1.1</code> \u2192 <code>4.2.0</code></li> <li><code>packaging</code>: <code>25.0</code> \u2192 <code>26.0</code></li> <li><code>black</code>: <code>25.12.0</code> \u2192 <code>26.1.0</code></li> <li><code>mkdocstrings[python]</code>: <code>1.0.0</code> \u2192 <code>1.0.1</code></li> <li><code>pymdown-extensions</code>: <code>10.20</code> \u2192 <code>10.20.1</code></li> </ul>"},{"location":"release-notes/#latest-changes","title":"Latest Changes","text":""},{"location":"release-notes/#many-fixes-enhancements-and-increasing-code-coverage-2616beta","title":"Many fixes, enhancements, and increasing code coverage (26.1.6.beta)","text":""},{"location":"release-notes/#changes","title":"Changes","text":"<ul> <li>bumping version to 26.1.6.beta (#68) (@devsetgo)</li> <li>feat(examples,docs): add plain HTML style support and document render\u2026 (#67) (@devsetgo)</li> <li>improving documents (#59) (@devsetgo)</li> <li>improving test coverage (#58) (@devsetgo)</li> <li>improving reliability rating (#57) (@devsetgo)</li> <li>working on sonarcloud issue (#41) (@devsetgo)</li> <li>fixing examples (#33) (@devsetgo)</li> </ul>"},{"location":"release-notes/#features","title":"Features","text":"<ul> <li>working on example. (#65) (@devsetgo)</li> <li>Improvements - docs, examples, and bug fixes (#43) (@devsetgo)</li> <li>34 add timing (#42) (@devsetgo)</li> <li>adding start line and end line for HTML sent to browser (#32) (@devsetgo)</li> </ul>"},{"location":"release-notes/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>working on material design render issues (#66) (@devsetgo)</li> <li>working on example. (#65) (@devsetgo)</li> <li>Improvements - docs, examples, and bug fixes (#43) (@devsetgo)</li> </ul>"},{"location":"release-notes/#maintenance","title":"Maintenance","text":"<ul> <li>pip(deps): bump tox from 4.36.0 to 4.44.0 (#60) (@dependabot[bot])</li> <li>pip(deps): bump mkdocs-material from 9.7.1 to 9.7.2 (#61) (@dependabot[bot])</li> <li>pip(deps): bump isort from 7.0.0 to 8.0.0 (#62) (@dependabot[bot])</li> <li>pip(deps): bump flask from 3.1.2 to 3.1.3 (#63) (@dependabot[bot])</li> <li>pip(deps): bump autoflake from 2.3.1 to 2.3.3 (#64) (@dependabot[bot])</li> <li>pip(deps): bump pytest-html from 4.1.1 to 4.2.0 (#45) (@dependabot[bot])</li> <li>pip(deps): bump ruff from 0.14.14 to 0.15.0 (#44) (@dependabot[bot])</li> <li>pip(deps): bump tqdm from 4.67.1 to 4.67.3 (#47) (@dependabot[bot])</li> <li>pip(deps): bump fastapi[all] from 0.121.2 to 0.128.4 (#48) (@dependabot[bot])</li> <li>pip(deps): bump mkdocstrings[python] from 1.0.0 to 1.0.1 (#39) (@dependabot[bot])</li> <li>pip(deps): bump pymdown-extensions from 10.20 to 10.20.1 (#36) (@dependabot[bot])</li> <li>github-actions(deps): bump release-drafter/release-drafter from 6.1.0 to 6.2.0 (#35) (@dependabot[bot])</li> <li>pip(deps): bump black from 25.12.0 to 26.1.0 (#37) (@dependabot[bot])</li> <li>pip(deps): bump ruff from 0.14.11 to 0.14.14 (#38) (@dependabot[bot])</li> <li>pip(deps): bump packaging from 25.0 to 26.0 (#40) (@dependabot[bot])</li> </ul>"},{"location":"release-notes/#contributors","title":"Contributors","text":"<p>@dependabot[bot], @devsetgo and dependabot[bot]</p> <p>Published Date: 2026 February 22, 16:35</p>"},{"location":"release-notes/#additional-work-for-self-contained-untagged-bfb3bb98aa31ca386d88","title":"Additional Work for Self-Contained (untagged-bfb3bb98aa31ca386d88)","text":""},{"location":"release-notes/#changes_1","title":"Changes","text":""},{"location":"release-notes/#features_1","title":"Features","text":"<ul> <li>Fix of self-contained and documentation updates (#31) (@devsetgo)</li> </ul>"},{"location":"release-notes/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fix of self-contained and documentation updates (#31) (@devsetgo)</li> <li>deploy docs (#28) (@devsetgo)</li> <li>working on documentation flow bugs (#27) (@devsetgo)</li> <li>working on issue to fix publishing failure (#26) (@devsetgo)</li> </ul>"},{"location":"release-notes/#contributors_1","title":"Contributors","text":"<p>@devsetgo</p> <p>Published Date: 2026 January 18, 13:57</p>"},{"location":"release-notes/#bug-fixes-and-improvements-2612beta","title":"Bug fixes and Improvements (26.1.2.beta)","text":""},{"location":"release-notes/#changes_2","title":"Changes","text":"<ul> <li>Publishing Improvements (#17) (@devsetgo)</li> <li>Doc (#16) (@devsetgo)</li> <li>GitHub Actions Improvements (#10) (@devsetgo)</li> <li>first release (#9) (@devsetgo)</li> <li>working on documentation (#5) (@devsetgo)</li> <li>working on coverage (#4) (@devsetgo)</li> </ul>"},{"location":"release-notes/#features_2","title":"Features","text":"<ul> <li>Improving Workflow (#1) (@devsetgo)</li> </ul>"},{"location":"release-notes/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>18 bootstrap not included in self contained example (#24) (@devsetgo)</li> <li>Fix model-list delete for dynamically added items (#23) (@devsetgo)</li> <li>working on coverage issue (#3) (@devsetgo)</li> <li>working on publishing issue (#2) (@devsetgo)</li> </ul>"},{"location":"release-notes/#maintenance_1","title":"Maintenance","text":"<ul> <li>github-actions(deps): bump actions/upload-pages-artifact from 3 to 4 (#19) (@dependabot[bot])</li> <li>updating release drafter (#11) (@devsetgo)</li> <li>Pre-Release Checks (#6) (@devsetgo)</li> </ul>"},{"location":"release-notes/#contributors_2","title":"Contributors","text":"<p>@dependabot[bot], @devsetgo and dependabot[bot]</p> <p>Published Date: 2026 January 09, 21:46</p>"},{"location":"release-notes/#initial-beta-release-2611beta","title":"Initial Beta Release (26.1.1.beta)","text":""},{"location":"release-notes/#changes_3","title":"Changes","text":"<ul> <li>GitHub Actions Improvements (#10) (@devsetgo)</li> <li>first release (#9) (@devsetgo)</li> <li>working on documentation (#5) (@devsetgo)</li> <li>working on coverage (#4) (@devsetgo)</li> </ul>"},{"location":"release-notes/#features_3","title":"Features","text":"<ul> <li>Improving Workflow (#1) (@devsetgo)</li> </ul>"},{"location":"release-notes/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>working on coverage issue (#3) (@devsetgo)</li> <li>working on publishing issue (#2) (@devsetgo)</li> </ul>"},{"location":"release-notes/#maintenance_2","title":"Maintenance","text":"<ul> <li>updating release drafter (#11) (@devsetgo)</li> <li>Pre-Release Checks (#6) (@devsetgo)</li> </ul>"},{"location":"release-notes/#contributors_3","title":"Contributors","text":"<p>@devsetgo</p> <p>Published Date: 2026 January 02, 19:13</p>"},{"location":"review/","title":"Codebase Review \u2013 pydantic-schemaforms","text":"<p>Date: 2025-12-21 (Updated)</p>"},{"location":"review/#executive-summary","title":"Executive Summary","text":"<p><code>pydantic-schemaforms</code> is in a solid place architecturally: there is now a single schema\u2192field\u2192layout rendering pipeline, theme/style are first-class and overrideable, and the test suite exercises both sync and async rendering across layout primitives. The remaining work is less about \u201cmore features\u201d and more about locking the product to its original promise:</p> <ul> <li> <p>Python 3.14+ only: this library targets Python 3.14 and higher, and does not support earlier Python versions.</p> </li> <li> <p>ship all required HTML/CSS/JS from the library (no external CDNs by default)</p> </li> <li>keep UI + validation configuration expressed via Pydantic (schema is the source of truth)</li> <li>make sync + async usage boringly simple (one obvious way)</li> <li>add an optional debug rendering mode that helps adoption without changing normal UX</li> </ul> <p>The renderer refactor eliminated shared mutable state and restored the enhanced/material renderers to a working baseline. Schema metadata is cached, field rendering is centralized, and model-list nesting now feeds explicit <code>RenderContext</code> objects. Django integration has been removed (Flask/FastAPI remain), and the JSON/OpenAPI generators now source constraints directly from Pydantic field metadata, unblocking the integration tests. Renderer themes now include a formal <code>FrameworkTheme</code> registry (Bootstrap/Material/plain) plus <code>MaterialEmbeddedTheme</code>, and both <code>EnhancedFormRenderer</code> and <code>FieldRenderer</code> source their form/input/button classes from the active theme before falling back to legacy framework config.</p> <p>Latest (Dec 7, 2025): Theme-driven form chrome extraction is complete. The new <code>FormStyle</code> contract centralizes all framework-specific markup (model lists, tabs, accordions, submit buttons, layout sections, and field-level help/error blocks) in a registry-based system. <code>FormStyleTemplates</code> dataclass now holds 15 template slots (expanded from 13: added <code>field_help</code> and <code>field_error</code> for field-level chrome routing), registered per-framework (Bootstrap/Material/Plain/Default) with graceful fallbacks. <code>RendererTheme</code> and <code>LayoutEngine</code> now query <code>FormStyle.templates</code> at render time instead of inlining markup, enabling runtime overrides without renderer edits. Version-aware style descriptors are supported (e.g., <code>get_form_style(\"bootstrap:5\")</code>, <code>get_form_style(\"material:3\")</code>) with fallback to framework defaults. FastAPI example hardened with absolute paths (<code>Path(__file__).resolve().parent</code>) for templates/static, resolving path issues in tests and different working directories. Validation engine consolidated: <code>ValidationResponse</code> and convenience validators now live in <code>validation.py</code>, <code>live_validation.py</code> consumes/re-exports without duplication, and 10 new consolidation tests were added. Tabs regression fixed: Bootstrap panels now render initial content (<code>show active</code>), Material tabs use shared tab CSS/JS classes so tabs switch correctly, and a layout-demo smoke test asserts initial tab content renders for both frameworks. Pydantic v2 deprecations eliminated: All Pydantic <code>Field()</code> kwargs now properly use <code>json_schema_extra</code> instead of extra kwargs; <code>min_items</code>/<code>max_items</code> replaced with <code>min_length</code>/<code>max_length</code> in FormField calls; Starlette <code>TemplateResponse</code> signature updated to new parameter order (request first). Deprecation warnings suppressed: pytest <code>filterwarnings</code> config reduces test output from 19 warnings to 1 without losing developer guidance (form_layouts deprecation and JSON schema hints remain available with <code>-W default</code>). Validation documentation added: New comprehensive <code>docs/validation_guide.md</code> (787 lines) documents the unified validation engine with ValidationResponse/FieldValidator/FormValidator APIs, server-side and HTMX validation flows, cross-field validation patterns, and end-to-end FastAPI examples.</p> <p>Latest (Dec 21, 2025): The core architecture is now strong enough to support the original product constraints (library supplies HTML/CSS/JS, configuration is expressed via Pydantic, sync+async are easy). The most important product-alignment work is now complete for assets and consistently enforced:</p> <ul> <li>Self-contained assets: Default rendering no longer emits external CDN URLs.</li> <li>HTMX is now vendored and inlined by default (offline-by-default).</li> <li>A CDN mode exists but is explicitly opt-in and pinned to the vendored manifest version.</li> <li>IMask is vendored and available when explicitly requested (e.g., SSN masking).</li> <li>Framework CSS/JS (Bootstrap + Materialize) are vendored and can be emitted inline in <code>asset_mode=\"vendored\"</code>.</li> <li>Consistent asset selection: A consistent <code>asset_mode</code> pattern is now threaded through the main entry points (enhanced renderer, modern renderer/builder, legacy wrappers) so \u201ccdn vs vendored\u201d behavior is deterministic.</li> <li>Operational stability: <code>vendor_manifest.json</code> checksum verification is enforced by tests, and pre-commit is configured to avoid mutating vendored assets and generated test artifacts.</li> <li>Debug rendering mode (COMPLETED): First-class debug panel now available via <code>debug=True</code> flag. The panel exposes (1) rendered HTML/assets, (2) the Python form/model source, (3) validation rules/schema, and (4) live payload with real-time form data capture. Implementation uses JavaScript event listeners to update the live tab as users interact with the form, handles nested model-list fields correctly, and is fully self-contained (inline CSS/JS). FastAPI example updated with <code>?debug=1</code> support on all routes, and tests verify correct behavior.</li> </ul>"},{"location":"review/#design-rules-nonnegotiables","title":"Design Rules (Non\u2011Negotiables)","text":"<p>These rules are intended to prevent \u201chelpful\u201d drift away from the original concept.</p> <ol> <li>Python version policy</li> <li>The library supports Python 3.14 and higher only.</li> <li> <p>Avoid guidance that suggests compatibility with older Python versions.</p> </li> <li> <p>Library ships the experience</p> <ul> <li>Default output must be fully functional offline: no third-party CDN assets (JS/CSS/fonts) unless explicitly opted in.</li> <li>Framework integrations may serve assets, but the assets must come from this package.</li> </ul> </li> <li> <p>Pydantic is the single source of truth</p> <ul> <li>Validation constraints, required/optional, and shape come from Pydantic schema/Field metadata.</li> <li>UI configuration is expressed via Pydantic-friendly metadata (<code>json_schema_extra</code> / form field helpers) rather than ad-hoc runtime flags.</li> <li>Avoid storing non-JSON-serializable objects in schema extras unless they are sanitized for schema generation.</li> </ul> </li> <li> <p>One obvious way (sync + async)</p> <ul> <li>There should be exactly one recommended sync entry point and one async entry point.</li> <li>All other helpers should be thin compatibility wrappers and should not diverge in behavior.</li> </ul> </li> <li> <p>Renderer outputs deterministic, self-contained HTML</p> <ul> <li>Rendering should not depend on global mutable state or ambient process configuration.</li> <li>Rendering should be deterministic for the same model + config.</li> </ul> </li> <li> <p>Debug mode is optional and non-invasive</p> <ul> <li>Debug UI must be off by default.</li> <li>When enabled, it should wrap the existing form (collapsed panel) and never change validation/rendering semantics.</li> <li>Debug surfaces should be \u201cread-only views\u201d of: rendered HTML/assets, model source (best effort), schema/validation rules, and live validation payloads.</li> </ul> </li> <li> <p>Extensibility stays declarative</p> <ul> <li>Plugins register inputs/layout renderers via the official registries; no monkeypatching required.</li> <li>Extension points should compose with themes/styles, not bypass them.</li> </ul> </li> </ol>"},{"location":"review/#critical-high-priority-findings","title":"Critical / High Priority Findings","text":"<ul> <li> <p>External CDN assets violate the self-contained requirement (Addressed)   Default output is now offline-by-default across the main entry points.</p> </li> <li> <p>HTMX is vendored and inlined by default.</p> </li> <li>An explicit <code>asset_mode=\"cdn\"</code> exists for users who want CDN delivery, but it is pinned to the vendored manifest version.</li> <li>IMask is vendored and available for secure inputs (e.g., SSN masking). It is not injected unless explicitly requested.</li> <li>Framework CSS/JS (Bootstrap + Materialize) are vendored and can be emitted in <code>asset_mode=\"vendored\"</code> (inline) to keep \u201cframework look\u201d self-contained.</li> <li>External CDN URLs still exist as an explicit opt-in (<code>asset_mode=\"cdn\"</code>) and are pinned to the vendored manifest versions.</li> </ul> <p>Files:   - <code>pydantic_schemaforms/render_form.py</code> (legacy wrapper)   - <code>pydantic_schemaforms/assets/runtime.py</code> (vendored HTMX + pinned CDN mode)   - <code>pydantic_schemaforms/rendering/themes.py</code> / <code>pydantic_schemaforms/enhanced_renderer.py</code> (asset-mode gating)   - <code>pydantic_schemaforms/modern_renderer.py</code>, <code>pydantic_schemaforms/integration/builder.py</code> (builder/modern entry points)   - <code>pydantic_schemaforms/form_layouts.py</code> (deprecated legacy layouts; now gated)</p> <p>Vendored dependency policy (implemented for HTMX; extendable for others)   - Default is offline: the default renderer output must not reference external CDNs.   - Pinned + auditable: every vendored asset must be pinned to an explicit version and recorded with <code>source_url</code> + <code>sha256</code> in a manifest.   - Licenses included: upstream license text (and any required notices) must be included in the repo alongside the vendored asset (or clearly referenced if inclusion is not permitted).   - Single update path: updates must happen via an explicit script + make target (no manual copy/paste), so diffs are reproducible.   - Opt-in CDN mode only: if a CDN mode exists, it must be explicitly selected (never default) and clearly documented as not-offline.</p> <p>What \u201ceasy to update\u201d means (definition)   - One command updates the pinned version, downloads the asset(s), writes/updates the manifest checksums, and runs a verification check.   - A CI/test check fails if any default render output contains external asset URLs.   - The update process is deterministic and reviewable (diff shows only asset bytes + manifest/version bump).   - Formatting/lint tooling must not modify vendored bytes (otherwise checksum verification breaks). Pre-commit should exclude <code>pydantic_schemaforms/assets/vendor/</code> from whitespace/EOF normalization hooks.</p> <ul> <li> <p>Multiple layout stacks compete for ownership (Resolved)   Layout definitions now live exclusively in <code>layout_base.BaseLayout</code> + <code>rendering/layout_engine</code>. The new <code>LayoutComposer</code> API exposes the canonical Horizontal/Vertical/Tabbed primitives, while <code>pydantic_schemaforms.layouts</code>/<code>pydantic_schemaforms.form_layouts</code> only re-export the engine with <code>DeprecationWarning</code>s. Enhanced and Material renderers both call into <code>LayoutEngine</code>, so markup is consistent across frameworks, and the tutorial documents LayoutComposer as the single supported API.   Files: <code>pydantic_schemaforms/rendering/layout_engine.py</code>, <code>pydantic_schemaforms/layouts.py</code>, <code>pydantic_schemaforms/form_layouts.py</code>, <code>pydantic_schemaforms/simple_material_renderer.py</code></p> </li> <li> <p>Renderer logic duplicated across frameworks (Resolved)   Enhanced and Simple Material share the same orchestration pipeline via the new <code>RendererTheme</code> abstraction and <code>MaterialEmbeddedTheme</code>, eliminating the duplicated CSS/JS scaffolding that previously lived in <code>simple_material_renderer.py</code>. The Modern renderer now builds a temporary <code>FormModel</code> and hands off to <code>EnhancedFormRenderer</code>, and the redundant <code>Py314Renderer</code> alias has been removed entirely. Framework-specific assets live in <code>RendererTheme</code> strategies, so there is a single schema walk/layout path regardless of entry point.   Files: <code>pydantic_schemaforms/enhanced_renderer.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code>, <code>pydantic_schemaforms/simple_material_renderer.py</code>, <code>pydantic_schemaforms/modern_renderer.py</code></p> </li> <li> <p>Integration helpers mix unrelated responsibilities (Addressed)   The synchronous/async adapters now live in <code>pydantic_schemaforms/integration/frameworks/</code>, leaving the root <code>integration</code> package to expose only builder/schema utilities by default. The module uses lazy exports so simply importing <code>pydantic_schemaforms.integration</code> no longer drags in optional framework glue unless those helpers are actually accessed.   Files: <code>pydantic_schemaforms/integration/__init__.py</code>, <code>pydantic_schemaforms/integration/frameworks/</code>, <code>pydantic_schemaforms/integration/builder.py</code></p> </li> </ul>"},{"location":"review/#medium-priority-refactors-opportunities","title":"Medium Priority Refactors &amp; Opportunities","text":"<ul> <li> <p>Input component metadata duplicated (Resolved)   Input classes now declare their <code>ui_element</code> (plus optional aliases) and a lightweight registry walks the class hierarchy to expose a mapping. <code>rendering/frameworks.py</code> imports that registry instead of maintaining its own list, so adding a new component only requires updating the input module where it already lives.   Files: <code>pydantic_schemaforms/inputs/base.py</code>, <code>pydantic_schemaforms/inputs/*</code>, <code>pydantic_schemaforms/inputs/registry.py</code>, <code>pydantic_schemaforms/rendering/frameworks.py</code></p> </li> <li> <p>Model list renderer mixes logic with theme markup (Resolved) <code>ModelListRenderer</code> now delegates both containers and per-item chrome through <code>RendererTheme</code> hooks: <code>render_model_list_container()</code> and the new <code>render_model_list_item()</code> (with Material/embedded overrides) wrap the renderer-supplied field grid so frameworks own every byte of markup. Bootstrap/Material share the same plumbing, labels/help/errors/add buttons stay in the theme, and tests cover that custom themes can inject their own classes when rendering lists.   Files: <code>pydantic_schemaforms/model_list.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code></p> </li> <li> <p>Template engine under-used (Resolved)   The new <code>FormStyle</code> contract (in <code>rendering/form_style.py</code>) extracts all framework-specific markup into <code>FormStyleTemplates</code> dataclass with 13 template slots: <code>form_wrapper</code>, <code>tab_layout</code>, <code>tab_button</code>, <code>tab_panel</code>, <code>accordion_layout</code>, <code>accordion_section</code>, <code>layout_section</code>, <code>layout_help</code>, <code>model_list_container</code>, <code>model_list_item</code>, <code>model_list_help</code>, <code>model_list_error</code>, and <code>submit_button</code>. Framework-specific bundles (Bootstrap, Material, Plain, Default) are registered in a centralized registry via <code>register_form_style()</code> and queried at render time with <code>get_form_style(framework, variant)</code>. <code>RendererTheme.render_submit_button()</code>, <code>render_model_list_*()</code> methods and <code>LayoutEngine</code> tab/accordion layouts all delegate to <code>FormStyle.templates</code> with graceful fallback to defaults, eliminating inline markup strings and enabling runtime overrides. Tests in <code>test_theme_hooks.py</code> (7 tests) verify custom FormStyle templates drive rendering. FastAPI example paths hardened to use <code>Path(__file__).resolve().parent</code> for templates and static dirs, working correctly from any working directory.   Files: <code>pydantic_schemaforms/rendering/form_style.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code>, <code>pydantic_schemaforms/rendering/layout_engine.py</code>, <code>examples/fastapi_example.py</code>, <code>tests/test_theme_hooks.py</code>, <code>tests/test_fastapi_example_smoke.py</code></p> </li> <li> <p>Runtime field registration surfaced (New)   Dynamically extending a <code>FormModel</code> is now supported via <code>FormModel.register_field()</code>, which wires the new <code>FieldInfo</code> into the schema cache and the validation stack by synthesizing a runtime subclass when necessary. Legacy <code>setattr(MyForm, name, Field(...))</code> still works for rendering, but the helper ensures <code>validate_form_data()</code> and HTMX live validation enforce the same constraints without manual plumbing.   Files: <code>pydantic_schemaforms/schema_form.py</code>, <code>pydantic_schemaforms/validation.py</code>, <code>tests/test_integration_workflow.py</code> TODO: The temporary <code>DynamicFormRuntime</code> created by <code>pydantic.create_model()</code> emits a <code>UserWarning</code> about shadowing parent attributes. If this becomes noisy, add a local <code>model_config = {\"ignored_types\": ...}</code> or suppress the warning via the helper before rebuilding the runtime model.</p> </li> <li> <p>Validation rule duplication (Resolved)   Validation is now canonical in <code>validation.py</code> (rules, <code>ValidationResponse</code>, convenience validators). <code>live_validation.py</code> consumes/re-exports without duplicating code. Added consolidation coverage (10 tests) for schema \u2192 live validator flow, convenience validators, and serialization.   Files: <code>pydantic_schemaforms/validation.py</code>, <code>pydantic_schemaforms/live_validation.py</code>, <code>pydantic_schemaforms/__init__.py</code>, <code>tests/test_validation_consolidation.py</code></p> </li> <li> <p>Input namespace still re-exports everything (Resolved)   The root package now exposes inputs via module-level <code>__getattr__</code>, delegating to a lazy-loading facade in <code>pydantic_schemaforms.inputs</code>. No wildcard imports remain, so importing <code>pydantic_schemaforms</code> does not instantiate every widget or template; consumers still get <code>from pydantic_schemaforms import TextInput</code> via the cached attribute. Future work can build on the same facade to document a plugin hook for third-party inputs.   Files: <code>pydantic_schemaforms/__init__.py</code>, <code>pydantic_schemaforms/inputs/__init__.py</code></p> </li> <li> <p>Integration facade duplicated across namespaces (Resolved)   The canonical sync/async helpers now live only in <code>integration/adapters.py</code>, <code>integration/sync.py</code>, and <code>integration/async_support.py</code>. The <code>integration.frameworks</code> package re-exports those implementations for legacy imports, and <code>FormIntegration.async_integration</code> was converted to a <code>@staticmethod</code> so the API is identical in both namespaces. Optional dependencies remain isolated via lazy imports, but there is now exactly one code path for validation + rendering logic.   Files: <code>pydantic_schemaforms/integration/__init__.py</code>, <code>pydantic_schemaforms/integration/adapters.py</code>, <code>pydantic_schemaforms/integration/frameworks/*</code></p> </li> <li> <p>Public sync/async \u201cone obvious way\u201d (Resolved)   Canonical entry points now exist and are exported from the root package:</p> </li> <li>Sync: <code>handle_form()</code></li> <li>Async: <code>handle_form_async()</code></li> </ul> <p>Legacy helpers (<code>handle_sync_form</code>, <code>handle_async_form</code>, <code>FormIntegration.*</code>) remain as compatibility wrappers.   Files: <code>pydantic_schemaforms/integration/adapters.py</code>, <code>pydantic_schemaforms/integration/__init__.py</code>, <code>pydantic_schemaforms/__init__.py</code>, <code>docs/quickstart.md</code>, <code>tests/test_integration.py</code></p> <ul> <li> <p>Theme/style contract centralized <code>RendererTheme</code> now includes concrete <code>FrameworkTheme</code> subclasses for Bootstrap/Material/plain plus <code>get_theme_for_framework</code>, and both enhanced + field renderers request classes/assets from the active theme before falling back to legacy configs. <code>FormStyle</code> registry now handles framework-level templates (including field-level chrome) and supports version-aware descriptors (e.g., <code>bootstrap:5</code>, <code>material:3</code>) with fallbacks to base framework/default.   Files: <code>pydantic_schemaforms/enhanced_renderer.py</code>, <code>pydantic_schemaforms/rendering/themes.py</code>, <code>pydantic_schemaforms/rendering/field_renderer.py</code>, <code>pydantic_schemaforms/rendering/frameworks.py</code>, <code>pydantic_schemaforms/rendering/form_style.py</code></p> </li> <li> <p>Plugin hooks for inputs/layouts (NEW)   Input components can now be registered via <code>register_input_class()</code> and <code>register_inputs()</code> in <code>inputs/registry.py</code> with automatic cache invalidation. Layout renderers can be registered via <code>LayoutEngine.register_layout_renderer()</code> and referenced from form fields using <code>layout_handler</code> metadata. Both APIs support resettable state for testing. Docs page <code>docs/plugin_hooks.md</code> explains usage and packaging patterns.   Files: <code>pydantic_schemaforms/inputs/registry.py</code>, <code>pydantic_schemaforms/rendering/layout_engine.py</code>, <code>docs/plugin_hooks.md</code>, <code>tests/test_plugin_hooks.py</code></p> </li> </ul>"},{"location":"review/#testing-tooling-gaps","title":"Testing &amp; Tooling Gaps","text":"<ul> <li>\u2705 Renderer behavior E2E coverage (COMPLETED) \u2014 Added <code>tests/test_e2e_layouts_async.py</code> with 14 tests: unit tests for tab/accordion DOM structure, aria attributes, display state; integration tests for <code>LayoutDemonstrationForm</code> with nested fields and model lists; async equivalence tests. All passing.</li> <li>\u2705 CI/docs alignment (COMPLETED) \u2014 Documented <code>make tests</code> as single entry point in new <code>docs/testing_workflow.md</code> (comprehensive guide with test organization, linting rules, CI/CD integration, troubleshooting). Ruff now enabled in <code>.pre-commit-config.yaml</code> and enforced as part of <code>make tests</code> before pytest runs.</li> </ul>"},{"location":"review/#recommended-next-steps","title":"Recommended Next Steps","text":"<ol> <li>\u2705 Document unified validation engine (COMPLETED) \u2014 Created comprehensive <code>docs/validation_guide.md</code> (787 lines) with:</li> <li><code>ValidationResponse</code>, <code>FieldValidator</code>, <code>FormValidator</code>, and <code>ValidationSchema</code> API documentation</li> <li>Server-side validation patterns with <code>validate_form_data()</code> and custom rules</li> <li>Real-time HTMX validation with <code>LiveValidator</code> and <code>HTMXValidationConfig</code></li> <li>Cross-field validation examples (age consent, password matching, conditional fields)</li> <li>Convenience validators (<code>create_email_validator()</code>, <code>create_password_strength_validator()</code>)</li> <li>Complete end-to-end sync + HTMX flow example with FastAPI endpoints and HTML templates</li> <li>Testing patterns and Pydantic v2 deprecation resolution notes</li> <li> <p>References to layout-demo smoke test coverage and tab rendering verification</p> </li> <li> <p>\u2705 Suppress remaining expected deprecation warnings (COMPLETED) \u2014 Added <code>filterwarnings</code> to <code>[tool.pytest.ini_options]</code> in <code>pyproject.toml</code> to suppress intentional warnings: <code>form_layouts</code> deprecation notice (migration guidance), Pydantic JSON schema non-serializable defaults (informational), and Pydantic extra kwargs deprecation (handled in code). Result: test output reduced from 19 warnings to 1 in normal mode; warnings remain accessible via <code>pytest -W default</code>.</p> </li> <li> <p>\u2705 Field-level chrome routing (COMPLETED) \u2014 Extended <code>FormStyle</code> to support field-level help/error templating: Added <code>field_help</code> and <code>field_error</code> templates to <code>FormStyleTemplates</code> dataclass (15 slots total, up from 13), registered framework-specific versions for Bootstrap, Plain, and Material Design. Ready for field renderers to consume these templates; enables consistent field-level chrome across all frameworks without renderer edits.</p> </li> <li> <p>\u2705 Version-aware style variants (COMPLETED) \u2014 <code>FormStyle</code> descriptors accept framework + variant (e.g., <code>\"bootstrap:5\"</code>, <code>\"material:3\"</code>) with graceful fallbacks to the framework base and default style. Aliases registered for Bootstrap 5 and Material 3 reuse existing templates; lookup stays backward compatible.</p> </li> <li> <p>\u2705 Extension hooks for inputs/layouts (COMPLETED) \u2014 Plugin registration API added: <code>register_input_class()</code> / <code>register_inputs()</code> in <code>inputs/registry</code> with cache clearing, and <code>LayoutEngine.register_layout_renderer()</code> with metadata-driven dispatch. Documented in <code>docs/plugin_hooks.md</code> with examples and best practices.</p> </li> <li> <p>\u2705 Automated E2E coverage for layouts/async (COMPLETED) \u2014 Added comprehensive <code>tests/test_e2e_layouts_async.py</code> (14 tests) covering: unit tests for tab/accordion DOM structure, aria attributes, and display state; integration tests for <code>LayoutDemonstrationForm</code> tab/layout field rendering with nested content and model lists; async tests verifying <code>render_form_from_model_async()</code> produces identical HTML to sync path, handles errors gracefully, and supports concurrent rendering. All tests passing.</p> </li> <li> <p>\u2705 CI/docs alignment (COMPLETED) \u2014 Documented <code>make tests</code> as single entry point in new <code>docs/testing_workflow.md</code> (comprehensive guide with test organization, linting rules, CI/CD integration, troubleshooting). Ruff now enabled in <code>.pre-commit-config.yaml</code> and enforced as part of <code>make tests</code> before pytest runs. All 217+ tests passing with integrated linting.</p> </li> <li> <p>\u2705 Make asset delivery self-contained (Completed for HTMX + IMask + framework assets) \u2014 The default renderer output is offline-by-default.</p> <ul> <li>\u2705 HTMX is vendored and inlined by default; CDN mode is opt-in and pinned.</li> </ul> </li> <li> <p>\u2705 IMask is vendored (for SSN and other secure input types) and can be included explicitly.</p> <ul> <li>\u2705 Bootstrap + Materialize CSS/JS are vendored and can be emitted inline via <code>asset_mode=\"vendored\"</code> when framework assets are requested.</li> </ul> <p>Update workflow (implemented) - Vendoring and verification scripts/targets exist, and tests enforce \u201cno external URLs by default\u201d.   - <code>docs/assets.md</code> documents the <code>asset_mode</code> contract and the vendoring workflow.</p> </li> </ol> <p>Tooling note (important)   - Pre-commit should exclude vendored assets and generated artifacts (coverage/test reports, debug HTML) from whitespace/EOF fixers to keep checksum verification and <code>make tests</code> stable.</p> <ol> <li>\u2705 Define one canonical sync + one canonical async entry point (COMPLETED) \u2014 Canonical entry points exist and are documented:</li> <li>Sync: <code>handle_form()</code></li> <li>Async: <code>handle_form_async()</code></li> </ol> <p>Both are exported from <code>pydantic_schemaforms</code> and covered by integration tests.   Files: <code>pydantic_schemaforms/integration/adapters.py</code>, <code>pydantic_schemaforms/__init__.py</code>, <code>docs/quickstart.md</code>, <code>tests/test_integration.py</code></p> <ol> <li>\u2705 Add a first-class debug rendering mode (COMPLETED) \u2014 Implemented a <code>debug=True</code> option that wraps the form in a collapsed debug panel with tabs:</li> <li>Rendered output: raw HTML (including the CSS/JS assets block)</li> <li>Form/model source: Python source for the form class (best-effort via <code>inspect.getsource()</code>)</li> <li>Schema / validation: schema-derived constraints (field requirements, min/max, regex, etc.)</li> <li>Live payload: Real-time form data capture that updates as users type/interact with the form</li> </ol> <p>Implementation details:    - Debug panel is off by default and non-invasive (collapsed <code>&lt;details&gt;</code> element)    - JavaScript event listeners capture <code>input</code> and <code>change</code> events to update live payload    - Handles nested form data (model lists with <code>pets[0].name</code> notation)    - Proper checkbox handling (true/false instead of \"on\" or missing)    - Tab UI consistent across frameworks using inline styles/scripts    - Tests verify debug panel presence when enabled and absence by default    - FastAPI example updated to expose <code>?debug=1</code> query parameter on all form routes</p> <p>Files: <code>pydantic_schemaforms/enhanced_renderer.py</code> (debug panel builder), <code>pydantic_schemaforms/render_form.py</code> (debug flag forwarding), <code>tests/test_debug_mode.py</code> (2 tests), <code>examples/fastapi_example.py</code> (debug parameter on all routes)</p> <p>## Codebase Layout (Package Map)</p> <p>This section documents the git-tracked layout of the <code>pydantic_schemaforms/</code> package.</p> <p>Notes:</p> <ul> <li>Runtime-generated <code>__pycache__/</code> folders and <code>*.pyc</code> files are intentionally omitted here (they are not part of the source tree and should not be committed).</li> </ul> <p>### <code>pydantic_schemaforms/</code> (root package)</p> <ul> <li><code>pydantic_schemaforms/__init__.py</code> \u2014 Public package entry point (lazy exports) and top-level API surface.</li> <li><code>pydantic_schemaforms/enhanced_renderer.py</code> \u2014 Enhanced renderer pipeline (schema \u2192 fields \u2192 layout) with sync/async HTML entry points.</li> <li><code>pydantic_schemaforms/form_field.py</code> \u2014 <code>FormField</code> abstraction and higher-level field helpers aligned with the design vision.</li> <li><code>pydantic_schemaforms/form_layouts.py</code> \u2014 Legacy layout composition helpers (kept for compatibility; deprecated).</li> <li><code>pydantic_schemaforms/icon_mapping.py</code> \u2014 Framework icon mapping helpers (bootstrap/material icon name/class resolution).</li> <li><code>pydantic_schemaforms/input_types.py</code> \u2014 Input type constants, default mappings, and validation utilities for selecting HTML input types.</li> <li><code>pydantic_schemaforms/layout_base.py</code> \u2014 Shared base layout primitives used by the layout engine and renderer(s).</li> <li><code>pydantic_schemaforms/layouts.py</code> \u2014 Deprecated layout wrapper module (compatibility surface).</li> <li><code>pydantic_schemaforms/live_validation.py</code> \u2014 HTMX-oriented \u201clive validation\u201d plumbing and configuration.</li> <li><code>pydantic_schemaforms/model_list.py</code> \u2014 Rendering helpers for repeating/nested model lists.</li> <li><code>pydantic_schemaforms/modern_renderer.py</code> \u2014 \u201cModern\u201d renderer facade backed by the shared enhanced pipeline.</li> <li><code>pydantic_schemaforms/render_form.py</code> \u2014 Backwards-compatible rendering wrapper(s) for legacy entry points.</li> <li><code>pydantic_schemaforms/schema_form.py</code> \u2014 Pydantic-driven form model primitives (<code>FormModel</code>, <code>Field</code>, validator helpers, validation result types).</li> <li><code>pydantic_schemaforms/simple_material_renderer.py</code> \u2014 Minimal Material Design renderer implementation.</li> <li><code>pydantic_schemaforms/templates.py</code> \u2014 Python 3.14 template-string based templating helpers used throughout rendering.</li> <li><code>pydantic_schemaforms/validation.py</code> \u2014 Canonical validation rules/engine and serializable validation responses.</li> <li><code>pydantic_schemaforms/vendor_assets.py</code> \u2014 Vendoring/manifest helper utilities used to manage and verify shipped third-party assets.</li> <li><code>pydantic_schemaforms/version_check.py</code> \u2014 Python version checks (enforces Python 3.14+ assumptions like template strings).</li> </ul> <p>### <code>pydantic_schemaforms/assets/</code> (packaged assets)</p> <ul> <li><code>pydantic_schemaforms/assets/__init__.py</code> \u2014 Asset package marker.</li> <li><code>pydantic_schemaforms/assets/runtime.py</code> \u2014 Runtime helpers to load/inline assets and emit tags (vendored vs pinned CDN modes).</li> </ul> <p>#### <code>pydantic_schemaforms/assets/vendor/</code> (vendored third\u2011party assets)</p> <ul> <li><code>pydantic_schemaforms/assets/vendor/README.md</code> \u2014 Vendored asset policy and update workflow overview.</li> <li><code>pydantic_schemaforms/assets/vendor/vendor_manifest.json</code> \u2014 Pin list and SHA256 checksums for vendored assets (audit + verification).</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/bootstrap/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/bootstrap/bootstrap.min.css</code> \u2014 Vendored, minified Bootstrap CSS.</li> <li><code>pydantic_schemaforms/assets/vendor/bootstrap/bootstrap.bundle.min.js</code> \u2014 Vendored, minified Bootstrap JS bundle.</li> <li><code>pydantic_schemaforms/assets/vendor/bootstrap/LICENSE</code> \u2014 Upstream Bootstrap license text.</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/htmx/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/htmx/htmx.min.js</code> \u2014 Vendored, minified HTMX library.</li> <li><code>pydantic_schemaforms/assets/vendor/htmx/LICENSE</code> \u2014 Upstream HTMX license text.</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/imask/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/imask/imask.min.js</code> \u2014 Vendored, minified IMask library (used for masked inputs).</li> <li><code>pydantic_schemaforms/assets/vendor/imask/LICENSE</code> \u2014 Upstream IMask license text.</li> </ul> <p>##### <code>pydantic_schemaforms/assets/vendor/materialize/</code></p> <ul> <li><code>pydantic_schemaforms/assets/vendor/materialize/materialize.min.css</code> \u2014 Vendored, minified Materialize CSS.</li> <li><code>pydantic_schemaforms/assets/vendor/materialize/materialize.min.js</code> \u2014 Vendored, minified Materialize JS.</li> <li><code>pydantic_schemaforms/assets/vendor/materialize/LICENSE</code> \u2014 Upstream Materialize license text.</li> </ul> <p>### <code>pydantic_schemaforms/inputs/</code> (input components)</p> <ul> <li><code>pydantic_schemaforms/inputs/__init__.py</code> \u2014 Lazy-loading facade for input classes (keeps import cost low).</li> <li><code>pydantic_schemaforms/inputs/base.py</code> \u2014 Base input types, rendering utilities, and shared label/help/error builders.</li> <li><code>pydantic_schemaforms/inputs/datetime_inputs.py</code> \u2014 Date/time-related input components.</li> <li><code>pydantic_schemaforms/inputs/numeric_inputs.py</code> \u2014 Numeric/slider/range-related input components.</li> <li><code>pydantic_schemaforms/inputs/registry.py</code> \u2014 Runtime registry and discovery helpers for input components.</li> <li><code>pydantic_schemaforms/inputs/selection_inputs.py</code> \u2014 Select/checkbox/radio/toggle-related input components.</li> <li><code>pydantic_schemaforms/inputs/specialized_inputs.py</code> \u2014 Specialized inputs (file upload, color, hidden, csrf/honeypot, tags, etc.).</li> <li><code>pydantic_schemaforms/inputs/text_inputs.py</code> \u2014 Text-ish inputs (text, password, email, URL, phone, credit card, etc.).</li> </ul> <p>### <code>pydantic_schemaforms/integration/</code> (framework/application integration)</p> <ul> <li><code>pydantic_schemaforms/integration/__init__.py</code> \u2014 Integration facade with lazy exports of framework glue.</li> <li><code>pydantic_schemaforms/integration/adapters.py</code> \u2014 High-level sync/async integration entry points (<code>handle_form</code>, <code>handle_form_async</code>).</li> <li><code>pydantic_schemaforms/integration/async_support.py</code> \u2014 Framework-agnostic async request/validation helpers.</li> <li><code>pydantic_schemaforms/integration/builder.py</code> \u2014 Form builder utilities (prebuilt forms, page wrapper helpers, asset tag helpers).</li> <li><code>pydantic_schemaforms/integration/react.py</code> \u2014 JSON-schema-form-oriented integration helpers.</li> <li><code>pydantic_schemaforms/integration/schema.py</code> \u2014 JSON/OpenAPI schema generation utilities.</li> <li><code>pydantic_schemaforms/integration/sync.py</code> \u2014 Framework-agnostic sync request/validation helpers.</li> <li><code>pydantic_schemaforms/integration/utils.py</code> \u2014 Shared utilities for integrations (type mapping, framework selection, validation conversion).</li> <li><code>pydantic_schemaforms/integration/vue.py</code> \u2014 Vue integration helpers.</li> </ul> <p>#### <code>pydantic_schemaforms/integration/frameworks/</code> (compat + legacy namespace)</p> <ul> <li><code>pydantic_schemaforms/integration/frameworks/__init__.py</code> \u2014 Namespace package for framework adapters.</li> <li><code>pydantic_schemaforms/integration/frameworks/adapters.py</code> \u2014 Compatibility shim re-exporting the canonical adapter API.</li> <li><code>pydantic_schemaforms/integration/frameworks/async_support.py</code> \u2014 Compatibility shim re-exporting async helpers.</li> <li><code>pydantic_schemaforms/integration/frameworks/sync.py</code> \u2014 Compatibility shim re-exporting sync helpers.</li> </ul> <p>### <code>pydantic_schemaforms/rendering/</code> (shared rendering engine)</p> <ul> <li><code>pydantic_schemaforms/rendering/__init__.py</code> \u2014 Shared rendering module namespace.</li> <li><code>pydantic_schemaforms/rendering/context.py</code> \u2014 Render context objects passed through renderers/layouts.</li> <li><code>pydantic_schemaforms/rendering/field_renderer.py</code> \u2014 Field-level rendering logic used by multiple renderers.</li> <li><code>pydantic_schemaforms/rendering/form_style.py</code> \u2014 <code>FormStyle</code> contract/registry that centralizes framework templates.</li> <li><code>pydantic_schemaforms/rendering/frameworks.py</code> \u2014 Framework configuration and input component mapping lookup.</li> <li><code>pydantic_schemaforms/rendering/layout_engine.py</code> \u2014 Layout primitives and the engine that renders composed layouts.</li> <li><code>pydantic_schemaforms/rendering/schema_parser.py</code> \u2014 Schema parsing/metadata extraction (pydantic model \u2192 render plan).</li> <li><code>pydantic_schemaforms/rendering/theme_assets.py</code> \u2014 Default CSS/JS snippets for layout-oriented components.</li> <li><code>pydantic_schemaforms/rendering/themes.py</code> \u2014 Theme strategies and framework themes (bootstrap/material/plain + embedded variants).</li> </ul> <p>## Beta Release Readiness Assessment</p> <p>### \u2705 Product Vision Alignment</p> <p>All six Design Rules (Non-Negotiables) are now fully satisfied:</p> <ol> <li> <p>Library ships the experience \u2705</p> <ul> <li>Default output is offline-by-default (vendored HTMX, IMask, Bootstrap, Materialize)</li> <li>CDN mode exists but is explicit opt-in and pinned to manifest versions</li> <li>All assets are checksummed and verified by tests</li> </ul> </li> <li> <p>Pydantic is the single source of truth \u2705</p> <ul> <li>Validation constraints, required/optional come from Pydantic schema/Field metadata</li> <li>UI configuration via <code>json_schema_extra</code> and form field helpers</li> <li>Schema generation sanitizes non-serializable objects</li> </ul> </li> <li> <p>One obvious way (sync + async) \u2705</p> <ul> <li>Canonical sync entry point: <code>handle_form()</code></li> <li>Canonical async entry point: <code>handle_form_async()</code></li> <li>Both exported from root package with integration test coverage</li> </ul> </li> <li> <p>Renderer outputs deterministic, self-contained HTML \u2705</p> <ul> <li>No global mutable state in renderer pipeline</li> <li>Deterministic output for same model + config</li> <li>Theme/style configuration is explicit</li> </ul> </li> <li> <p>Debug mode is optional and non-invasive \u2705</p> <ul> <li>Off by default (<code>debug=False</code>)</li> <li>Collapsed panel when enabled, never changes validation/rendering semantics</li> <li>Read-only views of: rendered HTML, model source, schema/validation, live payload</li> </ul> </li> <li> <p>Extensibility stays declarative \u2705</p> <ul> <li>Plugin registration via official registries (<code>register_input_class</code>, <code>register_layout_renderer</code>)</li> <li>Extension points compose with themes/styles</li> <li>Documented in <code>docs/plugin_hooks.md</code></li> </ul> </li> </ol> <p>### \u2705 Core Features Complete</p> <p>Rendering Pipeline:   - \u2705 Enhanced renderer with schema \u2192 fields \u2192 layout orchestration   - \u2705 Theme-driven styling (Bootstrap, Material Design, Plain, Default)   - \u2705 Field-level rendering with help/error chrome   - \u2705 Layout engine (Vertical, Horizontal, Tabbed, Accordion)   - \u2705 Model list support with add/remove functionality   - \u2705 Async rendering equivalence to sync path</p> <p>Validation:   - \u2705 Server-side validation via Pydantic   - \u2705 HTMX live validation support   - \u2705 Custom field validators   - \u2705 Cross-field validation patterns   - \u2705 Comprehensive validation guide documentation</p> <p>Integration:   - \u2705 Flask integration helpers   - \u2705 FastAPI integration helpers (async-first)   - \u2705 Framework-agnostic sync/async adapters   - \u2705 Working examples for both frameworks</p> <p>Developer Experience:   - \u2705 Debug mode with live payload inspection   - \u2705 Comprehensive test suite (250+ tests passing)   - \u2705 Documentation (quickstart, tutorial, validation guide, assets guide, plugin hooks, testing workflow)   - \u2705 Ruff linting + pre-commit hooks   - \u2705 CI/CD pipeline with coverage reporting</p> <p>### \u2705 Quality Metrics</p> <ul> <li>Test Coverage: 250+ tests passing (see <code>htmlcov/</code> for detailed report)</li> <li>Linting: Ruff enabled in pre-commit, zero linting errors</li> <li>Python Version: 3.14+ only (clearly documented)</li> <li>Dependencies: Minimal (pydantic&gt;=2.7, pydantic-extra-types[all]&gt;=2.10.6)</li> <li>Optional Dependencies: FastAPI and Flask marked as optional</li> </ul> <p>### \u26a0\ufe0f Known Limitations (Acceptable for Beta)</p> <ol> <li> <p>Dynamic field validation warning: Pydantic emits a <code>UserWarning</code> when using <code>FormModel.register_field()</code> due to <code>create_model()</code> behavior. This is cosmetic and doesn't affect functionality. Can be suppressed or improved in future releases.</p> </li> <li> <p>Material Design assets: Currently using Materialize CSS (older). Could be upgraded to Material Web Components or MUI in a future release, but current implementation is functional.</p> </li> <li> <p>Documentation completeness: Core features are documented, but some advanced patterns (custom input components, complex layouts) could benefit from additional examples.</p> </li> </ol> <p>### \ud83d\udccb Release Checklist</p> <ul> <li>\u2705 All design rules satisfied</li> <li>\u2705 Core features complete and tested</li> <li>\u2705 Debug mode implemented</li> <li>\u2705 Examples working (Flask + FastAPI)</li> <li>\u2705 Documentation covers essential workflows</li> <li>\u2705 Test suite passing (250+ tests)</li> <li>\u2705 Linting clean</li> <li>\u2705 Version marked as beta in <code>pyproject.toml</code> (25.11.3.beta)</li> <li>\u2705 README.md indicates beta status</li> <li>\u23f3 CHANGELOG.md updates (should document all changes since last release)</li> <li>\u23f3 Release notes prepared (features, breaking changes, migration guide)</li> </ul> <p>### \ud83c\udfaf Recommendation</p> <p>pydantic-schemaforms is ready for beta release with the following considerations:</p> <ol> <li>Update CHANGELOG.md to document all changes, new features, and breaking changes since the last release</li> <li>Prepare release notes highlighting:<ul> <li>Debug mode as a major new feature</li> <li>Offline-by-default asset strategy</li> <li>Theme-driven rendering system</li> <li>Plugin extensibility</li> <li>Python 3.14+ requirement (breaking change if upgrading from older versions)</li> </ul> </li> <li>Tag the release as <code>v25.11.3-beta</code> (or use current version scheme)</li> <li>Publish to PyPI with beta classifier</li> <li>Announce the beta in relevant communities (Reddit r/Python, Python Discord, etc.) and request feedback</li> </ol> <p>The library has strong architectural foundations, clear design principles, comprehensive test coverage, and working examples. The beta period should focus on:   - Gathering user feedback on API ergonomics   - Identifying edge cases in real-world usage   - Polishing documentation based on user questions   - Building community examples/templates</p> <p>Next Actions After Beta Release:   - Monitor issue tracker for bug reports and feature requests   - Gather feedback on debug mode usability   - Consider Material Web Components migration for v2.0   - Expand documentation with more advanced patterns   - Build gallery of community examples</p>"},{"location":"testing_workflow/","title":"Testing &amp; Contribution Workflow","text":"<p>This document describes the authoritative workflow for running tests, linting, and contributing to pydantic-schemaforms.</p>"},{"location":"testing_workflow/#single-entry-point-make-tests","title":"Single Entry Point: <code>make tests</code>","text":"<p>Use <code>make tests</code> (or <code>make test</code>) as the single, canonical command for running all quality checks before committing:</p> <pre><code>make tests\n</code></pre> <p>This runs: 1. Pre-commit hooks (Ruff linting + formatting, YAML/TOML checks, trailing whitespace) 2. Pytest (217+ tests covering validation, rendering, async, layouts, integration) 3. Coverage badge generation (summarizes test coverage) 4. Ruff linting (import ordering, style, deprecated patterns) \u2014 now enforced via pre-commit</p>"},{"location":"testing_workflow/#what-changed","title":"What Changed","text":"<ul> <li>Ruff is now enabled in <code>.pre-commit-config.yaml</code> and runs as part of <code>make tests</code></li> <li>Pre-commit hooks are mandatory before pytest runs; if linting fails, tests don't start</li> <li>No manual ruff invocation needed \u2014 it's automatic via pre-commit</li> </ul>"},{"location":"testing_workflow/#workflow","title":"Workflow","text":""},{"location":"testing_workflow/#before-committing","title":"Before Committing","text":"<pre><code># Full quality check\nmake tests\n\n# Or run individual steps if debugging:\nmake ruff          # Lint + format only\nmake isort         # Sort imports\nmake cleanup       # Run all formatters (isort + ruff + autoflake)\n</code></pre>"},{"location":"testing_workflow/#what-happens-in-make-tests","title":"What Happens in <code>make tests</code>","text":"<pre><code>\ud83d\udd0d Running pre-commit (ruff, formatting, yaml/toml checks)...\n\u2705 Pre-commit passed. Running pytest...\n[217 tests run]\n\ud83d\udcca Generating coverage and test badges...\n\u2728 Tests complete. Badges updated.\n</code></pre>"},{"location":"testing_workflow/#test-organization","title":"Test Organization","text":"<p>Tests are organized in <code>tests/</code> directory:</p> Test File Purpose Count <code>test_layout_demo_smoke.py</code> Tab/accordion initial render 3 <code>test_e2e_layouts_async.py</code> E2E: structure, integration, async 14 <code>test_plugin_hooks.py</code> Input/layout registration 2 <code>test_model_list_integration.py</code> Model list rendering &amp; validation 4 <code>test_validation_consolidation.py</code> Validation engine unification 10 <code>test_layouts.py</code> Layout classes (tabs, accordions, cards) 35+ ... Other units, integration, fixtures 150+"},{"location":"testing_workflow/#linting-rules-ruff","title":"Linting Rules (Ruff)","text":"<p>Ruff checks for: - Import ordering (<code>from __future__</code> first, stdlib, third-party, local) - Unused imports and variables - Deprecated patterns (old Pydantic v1 syntax) - Style (line length, unused code) - Type hints (basic checks)</p> <p>If Ruff finds issues, run: <pre><code>make ruff  # Auto-fix what it can\n</code></pre></p> <p>Then manually review any remaining issues and re-run <code>make tests</code>.</p>"},{"location":"testing_workflow/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li>Local: <code>make tests</code> validates code before pushing</li> <li>GitHub Actions (<code>.github/workflows/testing.yml</code>): Runs same checks on each PR</li> <li>Pre-commit: Enabled for all developers via <code>.pre-commit-config.yaml</code></li> </ul>"},{"location":"testing_workflow/#dependencies","title":"Dependencies","text":"<p>All test dependencies are in <code>requirements.txt</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Key packages: - <code>pytest</code> + <code>pytest-asyncio</code> + <code>pytest-cov</code> (testing) - <code>ruff</code> (linting + formatting) - <code>isort</code> (import sorting) - <code>genbadge</code> (coverage reporting) - <code>pre-commit</code> (hook management)</p>"},{"location":"testing_workflow/#troubleshooting","title":"Troubleshooting","text":""},{"location":"testing_workflow/#pre-commit-not-found","title":"\"pre-commit not found\"","text":"<pre><code>pip install pre-commit\n# or\nmake install\n</code></pre>"},{"location":"testing_workflow/#pytest-not-found","title":"\"pytest not found\"","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"testing_workflow/#ruff-keeps-failing-on-the-same-file","title":"Ruff keeps failing on the same file","text":"<p>Check what Ruff found: <pre><code>make ruff\n</code></pre></p> <p>If it's an actual issue (not auto-fixable), edit the file manually and re-run.</p>"},{"location":"testing_workflow/#running-only-pytest-skip-pre-commit","title":"Running only pytest (skip pre-commit)","text":"<pre><code>pytest tests/\n</code></pre> <p>\u26a0\ufe0f Not recommended \u2014 linting failures will catch issues in CI anyway.</p>"},{"location":"testing_workflow/#running-a-specific-test","title":"Running a specific test","text":"<pre><code>pytest tests/test_validation_consolidation.py -v\npytest tests/test_e2e_layouts_async.py::TestAsyncFormRendering::test_async_render_returns_same_html_as_sync -v\n</code></pre>"},{"location":"testing_workflow/#contributing","title":"Contributing","text":"<ol> <li>Create a branch: <code>git checkout -b feature/my-feature</code></li> <li>Make changes, add tests</li> <li>Run <code>make tests</code> to validate</li> <li>Commit and push</li> <li>Open a PR \u2014 CI will run the same checks</li> </ol> <p>All PRs must pass: - \u2705 Ruff linting - \u2705 Import ordering (isort) - \u2705 pytest (all tests) - \u2705 Coverage thresholds</p>"},{"location":"timing/","title":"Render Timing","text":"<p>The pydantic-schemaforms library automatically measures the time it takes to render forms and provides multiple ways to view this performance data.</p>"},{"location":"timing/#overview","title":"Overview","text":"<p>Form rendering timing is always measured by the library, giving you insights into form generation performance. You control how and where this timing information is displayed through render-time options.</p>"},{"location":"timing/#display-methods","title":"Display Methods","text":""},{"location":"timing/#1-logging-default","title":"1. Logging (Default)","text":"<p>Render time is automatically logged at INFO level to the library's logger:</p> <pre><code>import logging\nfrom pydantic_schemaforms import render_form_html\n\n# Configure logging to see timing logs\nlogging.basicConfig(level=logging.INFO)\n\nhtml = render_form_html(MyForm)\n# Output: INFO pydantic_schemaforms.enhanced_renderer: Form rendered in 0.0045s\n</code></pre> <p>The logging happens regardless of whether you display timing visually. This means:</p> <ul> <li>\u2705 Timing is always tracked for performance monitoring</li> <li>\u2705 You can collect timing metrics in production (at INFO level)</li> <li>\u2705 No performance overhead from timing collection</li> </ul>"},{"location":"timing/#2-inline-display-show_timingtrue","title":"2. Inline Display (<code>show_timing=True</code>)","text":"<p>Add a small timing display below the submit button:</p> <pre><code>html = render_form_html(MyForm, show_timing=True)\n</code></pre> <p>This renders: <pre><code>&lt;div style=\"text-align: center; margin-top: 10px; font-size: 0.85rem; color: #666;\"&gt;\n  Rendered in 0.0045s\n&lt;/div&gt;\n</code></pre></p> <p>Use case: During development to see quick feedback on render performance.</p>"},{"location":"timing/#3-debug-panel-debugtrue","title":"3. Debug Panel (<code>debug=True</code>)","text":"<p>Include a comprehensive debug panel showing timing and other metadata:</p> <pre><code>html = render_form_html(MyForm, debug=True)\n</code></pre> <p>The debug panel displays in the form header: <pre><code>Debug panel (development only) \u2014 0.0045s render\n</code></pre></p> <p>And includes additional information: - Form name and model - Number of fields - Framework and layout info - Timing breakdown if available</p> <p>Use case: Development mode to understand form structure and performance.</p>"},{"location":"timing/#4-combined-display","title":"4. Combined Display","text":"<p>You can use both <code>show_timing</code> and <code>debug</code> simultaneously:</p> <pre><code>html = render_form_html(MyForm, show_timing=True, debug=True)\n</code></pre> <p>This shows timing in: 1. The inline display below submit button 2. The debug panel header 3. The INFO log</p>"},{"location":"timing/#practical-examples","title":"Practical Examples","text":""},{"location":"timing/#development-see-all-timing","title":"Development: See All Timing","text":"<pre><code># Enable debug panel with inline timing\nhtml = render_form_html(\n    MyForm,\n    debug=True,\n    show_timing=True,\n    framework=\"bootstrap\"\n)\n</code></pre>"},{"location":"timing/#production-collect-timing-metrics","title":"Production: Collect Timing Metrics","text":"<pre><code>import logging\n\n# Configure logging to collect timing in production\nlogging.basicConfig(level=logging.INFO)\n\n# Render normally - timing is logged automatically\nhtml = render_form_html(MyForm, framework=\"bootstrap\")\n</code></pre> <p>Parse logs to collect performance metrics.</p>"},{"location":"timing/#hide-timing-from-users-but-keep-logging","title":"Hide Timing from Users (but Keep Logging)","text":"<pre><code># Users won't see timing, but it's still logged\nhtml = render_form_html(MyForm, framework=\"bootstrap\")\n</code></pre>"},{"location":"timing/#performance-considerations","title":"Performance Considerations","text":"<p>The timing measurement itself has minimal overhead (typically &lt; 0.1ms). The overhead comes from:</p> <ol> <li>Calling <code>time.time()</code> twice (~0.001ms) - negligible</li> <li>Logging the result (~0.1-1ms if logging is configured) - depends on log handlers</li> <li>Rendering the HTML display (~0.01ms) - only if <code>show_timing=True</code></li> </ol> <p>In practice, form rendering typically takes 5-50ms depending on form complexity, making timing overhead &lt; 1% of total time.</p>"},{"location":"timing/#integration-with-application-logging","title":"Integration with Application Logging","text":"<p>The timing logs respect your application's logging configuration:</p> <pre><code>import logging\nfrom pydantic_schemaforms import render_form_html\n\n# Production: INFO level logs\nlogging.basicConfig(level=logging.INFO)\nhtml = render_form_html(MyForm)\n# \u2705 Timing appears in logs\n\n# Development: DEBUG level\nlogging.basicConfig(level=logging.DEBUG)\nhtml = render_form_html(MyForm)\n# \u2705 Timing + detailed library logs appear\n\n# Suppress library logs (but keep timing in code)\nlogging.getLogger('pydantic_schemaforms').setLevel(logging.WARNING)\nhtml = render_form_html(MyForm)\n# \u274c Timing logs suppressed (but timing still measured internally)\n</code></pre>"},{"location":"timing/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.responses import HTMLResponse\nfrom pydantic_schemaforms import render_form_html, FormModel, Field\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\n\napp = FastAPI()\n\nclass LoginForm(FormModel):\n    username: str = Field(...)\n    password: str = Field(..., ui_element=\"password\")\n\n@app.get(\"/login\", response_class=HTMLResponse)\nasync def login_page(debug: bool = False):\n    # Toggle timing/debug display via query parameter\n    html = render_form_html(\n        LoginForm,\n        show_timing=debug,\n        debug=debug,\n        framework=\"bootstrap\"\n    )\n\n    return f\"\"\"\n    &lt;!doctype html&gt;\n    &lt;html&gt;\n    &lt;head&gt;&lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Login&lt;/h1&gt;\n        {html}\n        &lt;p&gt;&lt;small&gt;\n            &lt;a href=\"?debug=true\"&gt;Show timing &amp; debug&lt;/a&gt;\n        &lt;/small&gt;&lt;/p&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre> <p>Visit <code>/login</code> for normal form, <code>/login?debug=true</code> to see timing and debug panel.</p>"},{"location":"timing/#reference","title":"Reference","text":""},{"location":"timing/#parameters","title":"Parameters","text":"Parameter Type Default Effect <code>show_timing</code> <code>bool</code> <code>False</code> Display timing below submit button <code>debug</code> <code>bool</code> <code>False</code> Show debug panel with timing in header <code>enable_logging</code> <code>bool</code> <code>False</code> Enable library DEBUG logging (separate from timing logs) <p>Note: Timing is always logged at INFO level, independent of the <code>enable_logging</code> parameter.</p>"},{"location":"timing/#logger-names","title":"Logger Names","text":"<ul> <li><code>pydantic_schemaforms.enhanced_renderer</code> - Timing logs and general renderer info</li> <li><code>pydantic_schemaforms</code> - Root logger for all library components</li> </ul>"},{"location":"timing/#timing-accuracy","title":"Timing Accuracy","text":"<p>Timing uses Python's <code>time.time()</code> function: - Precision: microsecond resolution (0.001ms) - Accuracy: depends on OS clock (typically within 1-5ms on modern systems) - Example: <code>0.0045s</code> means 4.5 milliseconds</p>"},{"location":"timing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"timing/#timing-not-appearing","title":"Timing Not Appearing","text":"<p>Problem: You set <code>show_timing=True</code> but don't see timing in HTML.</p> <p>Solution: Check that <code>show_timing=True</code> is actually being passed. Common mistakes:</p> <pre><code># \u274c Wrong - parameter ignored\nhtml = render_form_html(MyForm)\n\n# \u2705 Correct\nhtml = render_form_html(MyForm, show_timing=True)\n</code></pre>"},{"location":"timing/#logs-not-appearing","title":"Logs Not Appearing","text":"<p>Problem: Timing logs don't appear even with logging configured.</p> <p>Solution: Ensure logging level is at INFO or DEBUG:</p> <pre><code>import logging\n\n# \u274c WRONG - WARNING level suppresses INFO logs\nlogging.basicConfig(level=logging.WARNING)\n\n# \u2705 CORRECT - INFO level shows timing\nlogging.basicConfig(level=logging.INFO)\n</code></pre>"},{"location":"timing/#performance-unexpectedly-slow","title":"Performance Unexpectedly Slow","text":"<p>Problem: Form rendering takes &gt; 100ms.</p> <p>Solution: Check form complexity:</p> <ol> <li>Use <code>debug=True</code> to see form structure</li> <li>Check if rendering multiple forms in a loop</li> <li>Enable DEBUG logging for detailed timing breakdown:</li> </ol> <pre><code>logging.basicConfig(level=logging.DEBUG)\nhtml = render_form_html(MyForm, debug=True)\n</code></pre>"},{"location":"tutorial_fastapi/","title":"Tutorial: A Simple FastAPI Project","text":"<p>This tutorial walks through creating a small FastAPI app that renders a form from a Pydantic model using <code>pydantic-schemaforms</code>.</p> <p>It uses the async-first render API so large forms won\u2019t block the event loop.</p>"},{"location":"tutorial_fastapi/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.14+</li> </ul>"},{"location":"tutorial_fastapi/#note-model-first-rendering","title":"Note: model-first rendering","text":"<p>This tutorial uses the model-first API (recommended). You only need:</p> <ul> <li>Define a <code>FormModel</code></li> <li>Render it (async) with <code>render_form_html_async()</code> or <code>FormModel.render_form_async()</code></li> <li>Drop <code>{{ form_html | safe }}</code> into your template</li> </ul> <p>See docs/configuration.md.</p>"},{"location":"tutorial_fastapi/#1-create-a-project","title":"1) Create a project","text":"<pre><code>mkdir schemaforms-fastapi-demo\ncd schemaforms-fastapi-demo\npython -m venv .venv\nsource .venv/bin/activate\n</code></pre>"},{"location":"tutorial_fastapi/#2-install-dependencies","title":"2) Install dependencies","text":"<pre><code>pip install \"pydantic-schemaforms[fastapi]\" uvicorn\n</code></pre>"},{"location":"tutorial_fastapi/#3-create-mainpy","title":"3) Create <code>main.py</code>","text":"<p>Create a file named <code>main.py</code>:</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\n\nfrom pydantic_schemaforms import Field, FormModel, render_form_html_async\n\n\nclass User(FormModel):\n    name: str = Field(...)\n    email: str = Field(..., ui_element=\"email\")\n\n\napp = FastAPI(title=\"SchemaForms Demo\")\n\n\n@app.api_route(\"/user\", methods=[\"GET\", \"POST\"], response_class=HTMLResponse)\nasync def user_form(request: Request):\n    form_data = {}\n    errors = {}\n\n    if request.method == \"POST\":\n        submitted = dict(await request.form())\n        form_data = submitted\n        try:\n            User(**submitted)\n        except Exception as exc:\n            errors = {\"form\": str(exc)}\n\n    form_html = await render_form_html_async(\n        User,\n        form_data=form_data,\n        errors=errors,\n        submit_url=\"/user\",\n    )\n\n    return f\"\"\"\n    &lt;html&gt;\n      &lt;body&gt;\n        &lt;h1&gt;User&lt;/h1&gt;\n        {form_html}\n      &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre> <p>You can also use <code>await User.render_form_async(...)</code> if you prefer a model method.</p>"},{"location":"tutorial_fastapi/#4-run-the-server","title":"4) Run the server","text":"<pre><code>uvicorn main:app --reload\n</code></pre> <p>Open http://127.0.0.1:8000/user</p>"},{"location":"tutorial_fastapi/#sync-vs-async-whats-the-difference","title":"Sync vs Async (what\u2019s the difference?)","text":""},{"location":"tutorial_fastapi/#render_form_html-sync","title":"<code>render_form_html()</code> (sync)","text":"<p>Use <code>render_form_html()</code> when your web framework is synchronous (WSGI) and you already have submitted data as a plain <code>dict</code>.</p> <p>Typical environments:</p> <ul> <li>Flask / Django (classic request/response)</li> <li>CLI apps or scripts that validate a dict</li> </ul> <p>Example (Flask):</p> <pre><code>from flask import Flask, request\n\nfrom pydantic_schemaforms import Field, FormModel, render_form_html\n\n\nclass User(FormModel):\n    name: str = Field(...)\n    email: str = Field(..., ui_element=\"email\")\n\n\napp = Flask(__name__)\n\n\n@app.route(\"/user\", methods=[\"GET\", \"POST\"])\ndef user_form():\n    if request.method == \"POST\":\n        form_data = request.form.to_dict()\n        errors = {}\n        try:\n            User(**form_data)\n        except Exception as exc:\n            errors = {\"form\": str(exc)}\n\n        return render_form_html(User, form_data=form_data, errors=errors, submit_url=\"/user\")\n\n    return render_form_html(User, submit_url=\"/user\")\n</code></pre>"},{"location":"tutorial_fastapi/#render_form_html_async-async","title":"<code>render_form_html_async()</code> (async)","text":"<p>Use <code>render_form_html_async()</code> when you are in an async runtime (ASGI) and you are already <code>await</code>-ing things (like <code>request.form()</code> in FastAPI/Starlette).</p> <p>Typical environments:</p> <ul> <li>FastAPI / Starlette</li> <li>Any async stack where you want to keep the request handler non-blocking</li> </ul>"},{"location":"tutorial_fastapi/#important-fastapi-note","title":"Important FastAPI note","text":"<p>FastAPI\u2019s <code>Request.form()</code> is async, so the most natural implementation is an <code>async def</code> route and <code>render_form_html_async()</code>.</p> <p>If you already have a <code>dict</code> of submitted data (for example from a different parsing path), you can still call the sync renderer inside an <code>async def</code> route \u2014 but for large forms, the async renderer avoids blocking the event loop.</p>"},{"location":"tutorial_fastapi/#next-steps","title":"Next steps","text":"<ul> <li>Learn about asset delivery (<code>asset_mode</code>) in <code>docs/assets.md</code></li> <li>See the broader integration pattern in <code>docs/quickstart.md</code></li> </ul>"},{"location":"validation_guide/","title":"Unified Validation Engine Guide","text":"<p>Complete guide to validation in pydantic-schemaforms: server-side, real-time HTMX, and cross-field patterns.</p>"},{"location":"validation_guide/#overview","title":"Overview","text":"<p>The pydantic-schemaforms validation system is consolidated into a single, unified engine that works seamlessly across: - Server-side validation via <code>validate_form_data()</code> and <code>FormValidator</code> - Real-time HTMX validation via <code>LiveValidator</code> and field-level validators - Cross-field validation via form-level rules - Convenience validators for common patterns (email, password strength)</p> <p>All validation rules live in <code>pydantic_schemaforms/validation.py</code>, re-exported from <code>pydantic_schemaforms/live_validation.py</code> for convenience, eliminating code duplication and ensuring consistency across all validation flows.</p>"},{"location":"validation_guide/#core-concepts","title":"Core Concepts","text":""},{"location":"validation_guide/#validationresponse","title":"ValidationResponse","text":"<p>The canonical response object for all validation operations (server-side or HTMX):</p> <pre><code>from pydantic_schemaforms import ValidationResponse\n\nresponse = ValidationResponse(\n    field_name=\"email\",\n    is_valid=True,\n    errors=[],                          # List of error messages\n    warnings=[],                        # List of warnings (non-blocking)\n    suggestions=[\"Example: user@example.com\"],  # Helpful hints\n    value=\"user@example.com\",           # The validated value\n    formatted_value=\"user@example.com\"  # Optionally formatted (e.g., lowercase)\n)\n\n# Serialize for HTMX responses\njson_str = response.to_json()\ndict_response = response.to_dict()\n</code></pre>"},{"location":"validation_guide/#validationschema-fieldvalidator","title":"ValidationSchema &amp; FieldValidator","text":"<p>Build reusable validation schemas from individual field validators:</p> <pre><code>from pydantic_schemaforms.validation import ValidationSchema, FieldValidator\n\n# Create a schema with multiple fields\nschema = ValidationSchema()\n\n# Add field validators\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nschema.add_field(email_validator)\n\npassword_validator = FieldValidator(\"password\")\npassword_validator.add_rule(\n    LengthRule(min=8, message=\"Minimum 8 characters required\")\n)\nschema.add_field(password_validator)\n\n# Build HTMX live validator from schema\nlive_validator = schema.build_live_validator()\n</code></pre>"},{"location":"validation_guide/#formvalidator","title":"FormValidator","text":"<p>Validate entire forms with both field-level and cross-field rules:</p> <pre><code>from pydantic_schemaforms.validation import FormValidator\n\nform_validator = FormValidator()\n\n# Add field validators\nform_validator.field(\"age\").add_rule(NumericRangeRule(min=0, max=150))\nform_validator.field(\"email\").add_rule(EmailRule())\n\n# Add cross-field validation\ndef validate_age_and_consent(data):\n    age = data.get(\"age\")\n    consent = data.get(\"parental_consent\")\n\n    if age is not None and age &lt; 18 and not consent:\n        return False, {\n            \"parental_consent\": [\"Parental consent required for users under 18\"]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_age_and_consent)\n\n# Validate form data\nis_valid, errors = form_validator.validate({\n    \"age\": 16,\n    \"email\": \"teen@example.com\",\n    \"parental_consent\": False\n})\n</code></pre>"},{"location":"validation_guide/#server-side-validation","title":"Server-Side Validation","text":""},{"location":"validation_guide/#using-validate_form_data","title":"Using validate_form_data()","text":"<p>For simple synchronous validation against a Pydantic <code>FormModel</code>:</p> <pre><code>from pydantic_schemaforms import FormModel, FormField, validate_form_data\n\nclass RegistrationForm(FormModel):\n    username: str = FormField(\n        title=\"Username\",\n        min_length=3,\n        max_length=20\n    )\n    email: str = FormField(\n        title=\"Email Address\",\n        input_type=\"email\"\n    )\n    password: str = FormField(\n        title=\"Password\",\n        input_type=\"password\",\n        min_length=8\n    )\n\n# Validate incoming form data\nresult = validate_form_data(RegistrationForm, {\n    \"username\": \"alice\",\n    \"email\": \"alice@example.com\",\n    \"password\": \"SecurePass123!\"\n})\n\nif result.is_valid:\n    print(f\"Valid! Data: {result.data}\")\nelse:\n    print(f\"Invalid! Errors: {result.errors}\")\n    # Result has: result.is_valid, result.data, result.errors\n</code></pre>"},{"location":"validation_guide/#using-formvalidator-with-pydantic-models","title":"Using FormValidator with Pydantic Models","text":"<p>For validation with additional custom rules:</p> <pre><code>from pydantic_schemaforms.validation import FormValidator\n\nform_validator = FormValidator()\nform_validator.field(\"username\").add_rule(LengthRule(min=3, max=20))\nform_validator.field(\"email\").add_rule(EmailRule())\nform_validator.field(\"password\").add_rule(LengthRule(min=8))\n\n# Validate and get results\nis_valid, errors = form_validator.validate({\n    \"username\": \"alice\",\n    \"email\": \"alice@example.com\",\n    \"password\": \"SecurePass123!\"\n})\n\n# Also validate against Pydantic model\nis_valid, errors = form_validator.validate_pydantic_model(\n    RegistrationForm,\n    request_data\n)\n</code></pre>"},{"location":"validation_guide/#real-time-htmx-validation","title":"Real-Time HTMX Validation","text":""},{"location":"validation_guide/#livevalidator-setup","title":"LiveValidator Setup","text":"<p>Use <code>LiveValidator</code> for server-side validation triggered via HTMX on blur/change events:</p> <pre><code>from pydantic_schemaforms.live_validation import LiveValidator, HTMXValidationConfig\nfrom pydantic_schemaforms.validation import FieldValidator, EmailRule\n\n# Configure HTMX behavior\nconfig = HTMXValidationConfig(\n    validate_on_blur=True,           # Validate when field loses focus\n    validate_on_input=False,         # Don't validate on every keystroke\n    validate_on_change=True,         # Validate when value changes\n    debounce_ms=300,                 # Wait 300ms before validation request\n    show_success_indicators=True,    # Visual feedback on valid input\n    show_warnings=True,              # Display warnings\n    show_suggestions=True,           # Show helpful hints\n    success_class=\"is-valid\",        # Bootstrap/custom CSS classes\n    error_class=\"is-invalid\",\n    warning_class=\"has-warning\",\n    loading_class=\"is-validating\"\n)\n\nlive_validator = LiveValidator(config)\n\n# Register field validators\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nlive_validator.register_field_validator(email_validator)\n\npassword_validator = FieldValidator(\"password\")\npassword_validator.add_rule(LengthRule(min=8))\nlive_validator.register_field_validator(password_validator)\n</code></pre>"},{"location":"validation_guide/#html-integration-with-htmx","title":"HTML Integration with HTMX","text":"<p>In your template, set up HTMX triggers for real-time validation:</p> <pre><code>&lt;!-- Form field with HTMX validation --&gt;\n&lt;input\n    type=\"email\"\n    name=\"email\"\n    id=\"email\"\n    class=\"form-control\"\n    placeholder=\"you@example.com\"\n    hx-post=\"/validate/email\"\n    hx-trigger=\"blur, change delay:300ms\"\n    hx-target=\"#email-feedback\"\n    hx-swap=\"outerHTML\"\n/&gt;\n\n&lt;!-- Validation feedback container --&gt;\n&lt;div id=\"email-feedback\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"validation_guide/#fastapi-endpoint-for-htmx-validation","title":"FastAPI Endpoint for HTMX Validation","text":"<pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom pydantic_schemaforms.live_validation import LiveValidator\nfrom pydantic_schemaforms.validation import FieldValidator, EmailRule\n\napp = FastAPI()\nlive_validator = LiveValidator()\n\n# Register validators\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nlive_validator.register_field_validator(email_validator)\n\n@app.post(\"/validate/email\", response_class=HTMLResponse)\nasync def validate_email(request: Request):\n    data = await request.form()\n    value = data.get(\"email\", \"\")\n\n    # Get validator for this field\n    validator = live_validator.get_field_validator(\"email\")\n    response = validator.validate(value)\n\n    # Render feedback HTML\n    if response.is_valid:\n        return f\"\"\"\n        &lt;div id=\"email-feedback\" class=\"valid-feedback\"&gt;\n            \u2713 Email looks good\n        &lt;/div&gt;\n        \"\"\"\n    else:\n        errors_html = \"\".join([f\"&lt;li&gt;{e}&lt;/li&gt;\" for e in response.errors])\n        return f\"\"\"\n        &lt;div id=\"email-feedback\" class=\"invalid-feedback\"&gt;\n            &lt;ul&gt;{errors_html}&lt;/ul&gt;\n        &lt;/div&gt;\n        \"\"\"\n</code></pre>"},{"location":"validation_guide/#building-livevalidator-from-validationschema","title":"Building LiveValidator from ValidationSchema","text":"<p>Automatically convert a schema to HTMX-ready validators:</p> <pre><code>from pydantic_schemaforms.validation import ValidationSchema, FieldValidator, EmailRule\n\nschema = ValidationSchema()\n\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(EmailRule())\nschema.add_field(email_validator)\n\n# Create HTMX live validator from schema\nlive_validator = schema.build_live_validator()\n\n# Now use live_validator in HTMX endpoints\n</code></pre>"},{"location":"validation_guide/#cross-field-validation","title":"Cross-Field Validation","text":""},{"location":"validation_guide/#form-level-rules","title":"Form-Level Rules","text":"<p>Validate fields that depend on other fields:</p> <pre><code>from pydantic_schemaforms.validation import FormValidator\n\nform_validator = FormValidator()\n\n# Individual field rules\nform_validator.field(\"age\").add_rule(NumericRangeRule(min=0, max=150))\nform_validator.field(\"parental_consent\").add_rule(RequiredRule())\n\n# Cross-field validation\ndef validate_minor_consent(data):\n    \"\"\"Minors must have parental consent.\"\"\"\n    age = data.get(\"age\")\n    consent = data.get(\"parental_consent\")\n\n    if age is not None and age &lt; 18 and not consent:\n        return False, {\n            \"parental_consent\": [\n                \"Parental consent is required for users under 18 years old\"\n            ]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_minor_consent)\n\n# Validate returns both field and cross-field errors\nis_valid, errors = form_validator.validate({\n    \"age\": 16,\n    \"parental_consent\": False\n})\n\n# errors = {\"parental_consent\": [\"Parental consent is required...\"]}\n</code></pre>"},{"location":"validation_guide/#conditional-field-validation","title":"Conditional Field Validation","text":"<p>Validate a field only if another field has a certain value:</p> <pre><code>def validate_emergency_contact(data):\n    \"\"\"Emergency contact required if no direct phone provided.\"\"\"\n    has_phone = bool(data.get(\"phone\"))\n    has_emergency_contact = bool(data.get(\"emergency_contact\"))\n\n    if not has_phone and not has_emergency_contact:\n        return False, {\n            \"emergency_contact\": [\n                \"Either a phone number or emergency contact is required\"\n            ]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_emergency_contact)\n</code></pre>"},{"location":"validation_guide/#password-matching-validation","title":"Password Matching Validation","text":"<pre><code>def validate_passwords_match(data):\n    \"\"\"Ensure password and confirm_password match.\"\"\"\n    password = data.get(\"password\", \"\")\n    confirm = data.get(\"confirm_password\", \"\")\n\n    if password and confirm and password != confirm:\n        return False, {\n            \"confirm_password\": [\"Passwords do not match\"]\n        }\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_passwords_match)\n</code></pre>"},{"location":"validation_guide/#convenience-validators","title":"Convenience Validators","text":""},{"location":"validation_guide/#email-validator","title":"Email Validator","text":"<pre><code>from pydantic_schemaforms.validation import create_email_validator\n\nemail_validator = create_email_validator()\n\nresponse = email_validator(\"user@example.com\")\n# ValidationResponse(field_name=\"email\", is_valid=True, ...)\n\nresponse = email_validator(\"invalid-email\")\n# ValidationResponse(\n#     field_name=\"email\",\n#     is_valid=False,\n#     errors=[\"Please enter a valid email address\"],\n#     suggestions=[\"Example: user@example.com\"],\n#     value=\"invalid-email\"\n# )\n</code></pre>"},{"location":"validation_guide/#password-strength-validator","title":"Password Strength Validator","text":"<pre><code>from pydantic_schemaforms.validation import create_password_strength_validator\n\npassword_validator = create_password_strength_validator(min_length=8)\n\nresponse = password_validator(\"WeakPass\")\n# ValidationResponse(\n#     field_name=\"password\",\n#     is_valid=False,\n#     errors=[\"Password must be at least 8 characters long\"],\n#     warnings=[\n#         \"Password should contain at least one uppercase letter\",\n#         \"Password should contain at least one number\"\n#     ],\n#     suggestions=[\n#         \"Add an uppercase letter (A-Z)\",\n#         \"Add a number (0-9)\"\n#     ],\n#     value=\"WeakPass\"\n# )\n\nresponse = password_validator(\"SecurePass123!\")\n# ValidationResponse(field_name=\"password\", is_valid=True, ...)\n</code></pre>"},{"location":"validation_guide/#common-validation-rules","title":"Common Validation Rules","text":""},{"location":"validation_guide/#built-in-rules","title":"Built-in Rules","text":"<p>The validation system includes pre-built rules for common patterns:</p> Rule Purpose Example <code>RequiredRule()</code> Field must have a value Required name field <code>LengthRule(min, max)</code> String length constraints 3\u201320 char username <code>EmailRule()</code> Valid email format Email field <code>PhoneRule()</code> Valid phone number Phone field <code>NumericRangeRule(min, max)</code> Numeric value range Age 0\u2013150 <code>DateRangeRule(min_date, max_date)</code> Date within range Future date only <code>RegexRule(pattern)</code> Custom regex pattern Custom format validation <code>CustomRule(func)</code> Custom validation function Complex logic"},{"location":"validation_guide/#example-complete-field-validation","title":"Example: Complete Field Validation","text":"<pre><code>from pydantic_schemaforms.validation import (\n    FieldValidator,\n    EmailRule,\n    LengthRule,\n    NumericRangeRule\n)\n\n# Email field validator\nemail_validator = FieldValidator(\"email\")\nemail_validator.add_rule(RequiredRule(\"Email is required\"))\nemail_validator.add_rule(EmailRule())\n\n# Username field validator\nusername_validator = FieldValidator(\"username\")\nusername_validator.add_rule(RequiredRule(\"Username is required\"))\nusername_validator.add_rule(LengthRule(min=3, max=20, message=\"3\u201320 characters\"))\n\n# Age field validator\nage_validator = FieldValidator(\"age\")\nage_validator.add_rule(NumericRangeRule(min=13, max=150, message=\"Must be 13+\"))\n\n# Use in form validator\nform_validator = FormValidator()\nform_validator.field(\"email\").add_rule(EmailRule())\nform_validator.field(\"username\").add_rule(LengthRule(min=3, max=20))\nform_validator.field(\"age\").add_rule(NumericRangeRule(min=13, max=150))\n</code></pre>"},{"location":"validation_guide/#sync-htmx-validation-flow","title":"Sync + HTMX Validation Flow","text":""},{"location":"validation_guide/#end-to-end-example","title":"End-to-End Example","text":"<p>Here's a complete registration form with both server validation and real-time HTMX feedback:</p>"},{"location":"validation_guide/#1-define-form-model","title":"1. Define Form Model","text":"<pre><code>from pydantic_schemaforms import FormModel, FormField\n\nclass RegistrationForm(FormModel):\n    username: str = FormField(\n        title=\"Username\",\n        input_type=\"text\",\n        min_length=3,\n        max_length=20,\n        help_text=\"3\u201320 alphanumeric characters\"\n    )\n\n    email: str = FormField(\n        title=\"Email Address\",\n        input_type=\"email\",\n        help_text=\"We'll send a confirmation link\"\n    )\n\n    password: str = FormField(\n        title=\"Password\",\n        input_type=\"password\",\n        min_length=8,\n        help_text=\"Must be at least 8 characters\"\n    )\n\n    confirm_password: str = FormField(\n        title=\"Confirm Password\",\n        input_type=\"password\",\n        help_text=\"Re-enter your password\"\n    )\n\n    age: int = FormField(\n        title=\"Age\",\n        input_type=\"number\",\n        ge=13,\n        le=150,\n        help_text=\"Must be 13 or older\"\n    )\n</code></pre>"},{"location":"validation_guide/#2-set-up-validation","title":"2. Set Up Validation","text":"<pre><code>from pydantic_schemaforms.validation import (\n    FormValidator,\n    FieldValidator,\n    EmailRule,\n    LengthRule,\n    NumericRangeRule\n)\n\n# Create form validator with all rules\nform_validator = FormValidator()\n\n# Field validators\nform_validator.field(\"username\").add_rule(\n    LengthRule(min=3, max=20, message=\"3\u201320 characters\")\n)\nform_validator.field(\"email\").add_rule(EmailRule())\nform_validator.field(\"password\").add_rule(\n    LengthRule(min=8, message=\"Minimum 8 characters\")\n)\nform_validator.field(\"age\").add_rule(\n    NumericRangeRule(min=13, max=150, message=\"Must be 13+\")\n)\n\n# Cross-field rules\ndef validate_passwords_match(data):\n    if data.get(\"password\") != data.get(\"confirm_password\"):\n        return False, {\"confirm_password\": [\"Passwords do not match\"]}\n    return True, {}\n\nform_validator.add_cross_field_rule(validate_passwords_match)\n\n# Live validator for HTMX\nlive_validator = form_validator.build_live_validator()\n</code></pre>"},{"location":"validation_guide/#3-fastapi-endpoints","title":"3. FastAPI Endpoints","text":"<pre><code>from fastapi import FastAPI, Request, Form\nfrom fastapi.responses import HTMLResponse, JSONResponse\nfrom pydantic_schemaforms import render_form, validate_form_data\n\napp = FastAPI()\n\n@app.get(\"/register\")\ndef show_registration():\n    form = RegistrationForm()\n    return render_form(form, framework=\"bootstrap\", submit_url=\"/register\")\n\n@app.post(\"/register\")\nasync def handle_registration(request: Request):\n    # Get form data\n    form_data = await request.form()\n\n    # Server-side validation\n    result = validate_form_data(RegistrationForm, dict(form_data))\n\n    if result.is_valid:\n        # Process registration\n        return JSONResponse({\n            \"success\": True,\n            \"message\": \"Registration successful!\"\n        })\n    else:\n        # Return form with errors\n        form = RegistrationForm()\n        return render_form(\n            form,\n            framework=\"bootstrap\",\n            errors=result.errors,\n            submit_url=\"/register\"\n        )\n\n# HTMX validation endpoints\n@app.post(\"/validate/username\")\nasync def validate_username(request: Request):\n    data = await request.form()\n    value = data.get(\"username\", \"\")\n\n    validator = form_validator.field(\"username\")\n    response = validator.validate(value)\n\n    if response.is_valid:\n        return HTMLResponse(\n            f'&lt;div class=\"valid-feedback\"&gt;\u2713 Available&lt;/div&gt;'\n        )\n    else:\n        errors = \"\".join([f\"&lt;li&gt;{e}&lt;/li&gt;\" for e in response.errors])\n        return HTMLResponse(\n            f'&lt;div class=\"invalid-feedback\"&gt;&lt;ul&gt;{errors}&lt;/ul&gt;&lt;/div&gt;'\n        )\n\n@app.post(\"/validate/email\")\nasync def validate_email(request: Request):\n    data = await request.form()\n    value = data.get(\"email\", \"\")\n\n    response = form_validator.field(\"email\").validate(value)\n\n    if response.is_valid:\n        return HTMLResponse(\n            f'&lt;div class=\"valid-feedback\"&gt;\u2713 Valid email&lt;/div&gt;'\n        )\n    else:\n        errors = \"\".join([f\"&lt;li&gt;{e}&lt;/li&gt;\" for e in response.errors])\n        return HTMLResponse(\n            f'&lt;div class=\"invalid-feedback\"&gt;&lt;ul&gt;{errors}&lt;/ul&gt;&lt;/div&gt;'\n        )\n</code></pre>"},{"location":"validation_guide/#4-html-template","title":"4. HTML Template","text":"<pre><code>&lt;form hx-post=\"/register\" hx-target=\"#form-result\"&gt;\n    &lt;!-- Username field with HTMX validation --&gt;\n    &lt;div class=\"form-group\"&gt;\n        &lt;label for=\"username\"&gt;Username&lt;/label&gt;\n        &lt;input\n            type=\"text\"\n            id=\"username\"\n            name=\"username\"\n            class=\"form-control\"\n            placeholder=\"3\u201320 characters\"\n            hx-post=\"/validate/username\"\n            hx-trigger=\"blur, change delay:300ms\"\n            hx-target=\"#username-feedback\"\n            hx-swap=\"outerHTML\"\n        /&gt;\n        &lt;div id=\"username-feedback\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;!-- Email field with HTMX validation --&gt;\n    &lt;div class=\"form-group\"&gt;\n        &lt;label for=\"email\"&gt;Email Address&lt;/label&gt;\n        &lt;input\n            type=\"email\"\n            id=\"email\"\n            name=\"email\"\n            class=\"form-control\"\n            placeholder=\"you@example.com\"\n            hx-post=\"/validate/email\"\n            hx-trigger=\"blur, change delay:300ms\"\n            hx-target=\"#email-feedback\"\n            hx-swap=\"outerHTML\"\n        /&gt;\n        &lt;div id=\"email-feedback\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;!-- Other fields... --&gt;\n\n    &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Register&lt;/button&gt;\n    &lt;div id=\"form-result\"&gt;&lt;/div&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"validation_guide/#testing-your-validators","title":"Testing Your Validators","text":"<p>The test suite includes comprehensive coverage. Use these patterns in your tests:</p> <pre><code>import pytest\nfrom pydantic_schemaforms.validation import (\n    FormValidator,\n    FieldValidator,\n    EmailRule,\n    ValidationResponse\n)\n\ndef test_email_validation():\n    email_validator = FieldValidator(\"email\")\n    email_validator.add_rule(EmailRule())\n\n    # Valid email\n    response = email_validator.validate(\"user@example.com\")\n    assert response.is_valid\n    assert response.errors == []\n\n    # Invalid email\n    response = email_validator.validate(\"not-an-email\")\n    assert not response.is_valid\n    assert len(response.errors) &gt; 0\n\ndef test_cross_field_validation():\n    form_validator = FormValidator()\n\n    def validate_passwords(data):\n        if data.get(\"password\") != data.get(\"confirm\"):\n            return False, {\"confirm\": [\"Passwords don't match\"]}\n        return True, {}\n\n    form_validator.add_cross_field_rule(validate_passwords)\n\n    is_valid, errors = form_validator.validate({\n        \"password\": \"secret\",\n        \"confirm\": \"different\"\n    })\n\n    assert not is_valid\n    assert \"confirm\" in errors\n</code></pre>"},{"location":"validation_guide/#layout-demo-tab-rendering-verification","title":"Layout Demo &amp; Tab Rendering Verification","text":"<p>The <code>tests/test_layout_demo_smoke.py</code> smoke test verifies that initial tab content renders correctly for both Bootstrap and Material frameworks:</p> <pre><code>def test_layout_demo_bootstrap_initial_tab_renders():\n    \"\"\"Verify Bootstrap tabs show initial tab content.\"\"\"\n    response = client.get(\"/layouts\")\n    assert response.status_code == 200\n    assert \"Tab 1 Content\" in response.text\n    # Assert tab buttons exist\n    assert 'class=\"nav-link active\"' in response.text\n\ndef test_layout_demo_material_initial_tab_renders():\n    \"\"\"Verify Material tabs show initial tab content.\"\"\"\n    response = client.get(\"/layouts?style=material\")\n    assert response.status_code == 200\n    # Assert initial content and Material tab classes\n    assert \"Initial Tab Content\" in response.text\n    assert 'data-toggle=\"tab\"' in response.text\n</code></pre> <p>This coverage ensures that tab layouts work correctly across frameworks.</p>"},{"location":"validation_guide/#pydantic-v2-deprecation-resolution","title":"Pydantic v2 Deprecation Resolution","text":"<p>As of this release, all Pydantic v2 deprecation warnings have been resolved:</p> <p>\u2705 Resolved Deprecations: - <code>min_items</code>/<code>max_items</code> \u2192 <code>min_length</code>/<code>max_length</code> in all FormField calls - Extra kwargs on <code>Field()</code> \u2192 properly use <code>json_schema_extra</code> - Starlette <code>TemplateResponse</code> signature updated to new parameter order</p> <p>Result: Deprecation warnings reduced from 23 \u2192 8 (removed 15 Pydantic deprecations). The remaining 8 warnings are intentional migration guides (<code>form_layouts</code> deprecation notice) and informational (JSON schema hints).</p> <p>Run validation tests: <pre><code>python -m pytest tests/test_validation_consolidation.py -v\npython -m pytest tests/test_layout_demo_smoke.py -v\n</code></pre></p>"},{"location":"validation_guide/#summary","title":"Summary","text":"<p>The unified validation engine provides:</p> <ol> <li>Canonical ValidationResponse for all validation flows</li> <li>Single code path via <code>validation.py</code> with re-exports from <code>live_validation.py</code></li> <li>Flexible rule composition via <code>FieldValidator</code> and <code>FormValidator</code></li> <li>HTMX integration via <code>LiveValidator</code> with configurable behavior</li> <li>Cross-field validation for dependent fields and complex rules</li> <li>Convenience validators for common patterns (email, password strength)</li> <li>Full async support for FastAPI and async frameworks</li> <li>Pydantic v2 compatibility with zero deprecation warnings in critical paths</li> </ol> <p>For questions or examples, see: - <code>tests/test_validation_consolidation.py</code> \u2014 Consolidated validation tests (10 tests) - <code>tests/test_layout_demo_smoke.py</code> \u2014 Layout/tab rendering verification - <code>examples/fastapi_example.py</code> \u2014 Real-world FastAPI integration</p>"}]}